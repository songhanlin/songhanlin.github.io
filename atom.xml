<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骑驴码梦</title>
  
  <subtitle>我一进门就看到常威在打来福~</subtitle>
  <link href="http://blog.julysong.com/atom.xml" rel="self"/>
  
  <link href="http://blog.julysong.com/"/>
  <updated>2025-02-20T06:39:02.270Z</updated>
  <id>http://blog.julysong.com/</id>
  
  <author>
    <name>TeenSong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NFT-集合</title>
    <link href="http://blog.julysong.com/2022/09/01/web3-sophomore-level9/"/>
    <id>http://blog.julysong.com/2022/09/01/web3-sophomore-level9/</id>
    <published>2022-09-01T10:52:54.000Z</published>
    <updated>2025-02-20T06:39:02.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/7411199b-6463-4ffa-803d-80afa30585ec">NFT-Collection</a></p><p>翻译: JulySong</p></blockquote><p>现在是你推出自己的 NFT 收藏的时候了 - <code>Crypto Devs</code>.</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level9/1.png?raw=true"></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>应该只存在 20 个 Crypto Dev NFT，并且每个都应该是唯一的。</li><li>用户应该能够通过一笔交易仅铸造 1 个 NFT。</li><li>白名单用户应在实际销售前有 5 分钟的预售期，保证每笔交易获得 1 NFT。</li><li>你的 NFT 收藏应该有一个网站。</li></ul><p>让我们开始建造 🚀</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>你应该已经完成了<a href="https://github.com/LearnWeb3DAO/Whitelist-Dapp">Whitelist dApp tutorial</a>教程</li></ul><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><ul><li><p>什么是不可替代代币？可替代意味着相同或可互换，例如 Eth 是可替代的。考虑到这一点，NFT 是独一无二的。每一个都是不同的。每个令牌都有独特的特征和价值。它们都可以相互区分并且不可互换，例如独特的艺术</p></li><li><p>什么是 ERC-721？ERC-721 是一个开放标准，描述了如何在 EVM（以太坊虚拟机）兼容的区块链上构建不可替代的代币；它是不可替代代币的标准接口；它有一套规则，可以很容易地使用 NFT。在继续之前，先看看<a href="https://docs.openzeppelin.com/contracts/3.x/api/token/erc721">ERC721</a>支持的所有功能</p></li></ul><h2 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h2><h3 id="喜欢视频？"><a href="#喜欢视频？" class="headerlink" title="喜欢视频？"></a>喜欢视频？</h3><p>如果您想从视频中学习，我们的 YouTube 上有本教程的录音。单击下面的屏幕截图观看视频，或继续阅读教程！</p><p><a href="https://youtu.be/VocEb6qYXKs">视频 1</a><br><a href="https://youtu.be/_g4UQHxhvPo">视频 2</a></p><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><ul><li><p>我们还将使用 Openzeppelin 的 <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol">Ownable.sol</a> 来帮助您管理<code>Ownership</code>合同</p><ul><li>默认情况下，Ownable 合约的所有者是部署它的帐户，这通常正是您想要的。</li><li>Ownable 还可以让您：<ul><li>将所有权从所有者帐户转移到新帐户，以及</li><li>rrenounceOwnership 让所有者放弃此管理特权，这是集中管理初始阶段结束后的常见模式。</li></ul></li></ul></li><li><p>我们还将使用 ERC721 的扩展，称为<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol">ERC721 Enumerable</a></p><ul><li>ERC721 Enumerable 可帮助您跟踪合约中的所有 tokenIds 以及给定合约的地址持有的 tokensIds。</li><li>在继续之前，请先看看它实现的<a href="https://docs.openzeppelin.com/contracts/4.x/api/token/erc721#ERC721Enumerable">功能</a></li></ul></li></ul><p>为了构建智能合约，我们将使用<a href="https://hardhat.org/">Hardhat</a>。Hardhat 是一个以太坊开发环境和框架，专为 Solidity 中的全栈开发而设计。简单来说，您可以编写智能合约、部署它们、运行测试和调试代码。</p><ul><li>要设置 Hardhat 项目，请打开终端并执行以下命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir NFT-Collection</span><br><span class="line">cd NFT-Collection</span><br><span class="line">mkdir hardhat-tutorial</span><br><span class="line">cd hardhat-tutorial</span><br><span class="line">npm init --yes</span><br><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure><ul><li>在安装 Hardhat 的同一目录中运行：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Select Create a Javascript project</span><br><span class="line">- Press enter for the already specified Hardhat Project root</span><br><span class="line">- Press enter for the question on if you want to add a .gitignore</span><br><span class="line">- Press enter for Do you want to install this sample project&#x27;s dependencies with npm (@nomicfoundation/hardhat-toolbox)?</span><br></pre></td></tr></table></figure><p>现在你有一个 hardhat 项目准备好了！</p><p>如果您在 Windows 上，请执行此额外步骤并安装这些库：)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure><ul><li>现在在同一个终端中安装<code>@openzeppelin/contracts</code>，因为我们将在我们的<code>CryptoDevs</code>合同中导入<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol">Openzeppelin’s ERC721Enumerable</a>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><ul><li><p>我们将需要调用您为之前级别部署的地址<code>Whitelist Contract</code>，以检查列入白名单的地址并授予他们预售访问权限。因为我们只需要调用 <code>mapping(address =&gt; bool) public whitelistedAddresses;</code> 我们可以为这个映射创建一个 <code>Whitelist contract</code> 带有函数的接口，这样我们就可以节省气体，因为我们不需要继承和部署整个<code>Whitelist Contract</code>，而只需要它的一部分。</p></li><li><p>在目录中创建一个新文件<code>contracts</code>并调用它<code>IWhitelist.sol</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">    pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">    interface IWhitelist &#123;</span><br><span class="line">        function whitelistedAddresses(address) external view returns (bool);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>现在让我们在目录中创建一个新文件<code>contracts</code>并调用它<code>CryptoDevs.sol</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">  pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">  import &quot;@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol&quot;;</span><br><span class="line">  import &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span><br><span class="line">  import &quot;./IWhitelist.sol&quot;;</span><br><span class="line"></span><br><span class="line">  contract CryptoDevs is ERC721Enumerable, Ownable &#123;</span><br><span class="line">      /**</span><br><span class="line">       * @dev _baseTokenURI 用于计算 &#123;tokenURI&#125;。如果设置，每个</span><br><span class="line">       * 令牌的结果 URI 将是 `baseURI` 和 `tokenId` 的串联。</span><br><span class="line">       */</span><br><span class="line">      string _baseTokenURI;</span><br><span class="line"></span><br><span class="line">      //  _price 是一个 Crypto Dev NFT 的价格</span><br><span class="line">      uint256 public _price = 0.01 ether;</span><br><span class="line"></span><br><span class="line">      // _paused 用于在紧急情况下暂停合约</span><br><span class="line">      bool public _paused;</span><br><span class="line"></span><br><span class="line">      // CryptoDev 的最大数量</span><br><span class="line">      uint256 public maxTokenIds = 20;</span><br><span class="line"></span><br><span class="line">      // 铸造的 tokenIds 总数</span><br><span class="line">      uint256 public tokenIds;</span><br><span class="line"></span><br><span class="line">      // 白名单合约实例</span><br><span class="line">      IWhitelist whitelist;</span><br><span class="line"></span><br><span class="line">      // 布尔值，用于跟踪预售是否开始</span><br><span class="line">      bool public presaleStarted;</span><br><span class="line"></span><br><span class="line">      // 预售结束时间的时间戳</span><br><span class="line">      uint256 public presaleEnded;</span><br><span class="line"></span><br><span class="line">      modifier onlyWhenNotPaused &#123;</span><br><span class="line">          require(!_paused, &quot;Contract currently paused&quot;);</span><br><span class="line">          _;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * @dev ERC721 构造函数接受一个 `name` 和一个 `symbol` 到令牌集合。</span><br><span class="line">       * 在我们的例子中，名称是“Crypto Devs”，符号是“CD”。</span><br><span class="line">       * Crypto Devs 的构造函数接受 baseURI 来为集合设置 _baseTokenURI。</span><br><span class="line">       * 它还初始化一个白名单接口的实例。</span><br><span class="line">       */</span><br><span class="line">      constructor (string memory baseURI, address whitelistContract) ERC721(&quot;Crypto Devs&quot;, &quot;CD&quot;) &#123;</span><br><span class="line">          _baseTokenURI = baseURI;</span><br><span class="line">          whitelist = IWhitelist(whitelistContract);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">      * @dev startPresale 开始预售白名单地址</span><br><span class="line">       */</span><br><span class="line">      function startPresale() public onlyOwner &#123;</span><br><span class="line">          presaleStarted = true;</span><br><span class="line">          // 将 presaleEnded 时间设置为当前时间戳 + 5 分钟</span><br><span class="line">          // Solidity 有很酷的时间戳语法（秒、分钟、小时、天、年）</span><br><span class="line">          presaleEnded = block.timestamp + 5 minutes;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">       * @dev presaleMint 允许用户在预售期间为每笔交易铸造一个 NFT。</span><br><span class="line">       */</span><br><span class="line">      function presaleMint() public payable onlyWhenNotPaused &#123;</span><br><span class="line">          require(presaleStarted &amp;&amp; block.timestamp &lt; presaleEnded, &quot;Presale is not running&quot;);</span><br><span class="line">          require(whitelist.whitelistedAddresses(msg.sender), &quot;You are not whitelisted&quot;);</span><br><span class="line">          require(tokenIds &lt; maxTokenIds, &quot;Exceeded maximum Crypto Devs supply&quot;);</span><br><span class="line">          require(msg.value &gt;= _price, &quot;Ether sent is not correct&quot;);</span><br><span class="line">          tokenIds += 1;</span><br><span class="line">          // _safeMint 是 _mint 函数的更安全版本，因为它确保</span><br><span class="line">          // 如果要铸造的地址是合约，那么它知道如何处理 ERC721 代币</span><br><span class="line">          // 如果要铸造的地址不是合约，它的工作方式与 _mint</span><br><span class="line">          _safeMint(msg.sender, tokenIds);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">      * @dev mint 允许用户在预售结束后为每笔交易铸造 1 个 NFT。</span><br><span class="line">      */</span><br><span class="line">      function mint() public payable onlyWhenNotPaused &#123;</span><br><span class="line">          require(presaleStarted &amp;&amp; block.timestamp &gt;=  presaleEnded, &quot;Presale has not ended yet&quot;);</span><br><span class="line">          require(tokenIds &lt; maxTokenIds, &quot;Exceed maximum Crypto Devs supply&quot;);</span><br><span class="line">          require(msg.value &gt;= _price, &quot;Ether sent is not correct&quot;);</span><br><span class="line">          tokenIds += 1;</span><br><span class="line">          _safeMint(msg.sender, tokenIds);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">      * @dev _baseURI 覆盖 Openzeppelin 的 ERC721 实现，默认情况下</span><br><span class="line">      * 返回 baseURI 的空字符串</span><br><span class="line">      */</span><br><span class="line">      function _baseURI() internal view virtual override returns (string memory) &#123;</span><br><span class="line">          return _baseTokenURI;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">      * @dev setPaused 使合约暂停或取消暂停</span><br><span class="line">       */</span><br><span class="line">      function setPaused(bool val) public onlyOwner &#123;</span><br><span class="line">          _paused = val;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      /**</span><br><span class="line">      * @devdraw 将合约中的所有以太币 * 发送给合约的所有者</span><br><span class="line">       */</span><br><span class="line">      function withdraw() public onlyOwner  &#123;</span><br><span class="line">          address _owner = owner();</span><br><span class="line">          uint256 amount = address(this).balance;</span><br><span class="line">          (bool sent, ) =  _owner.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">          require(sent, &quot;Failed to send Ether&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       // 接收以太币的函数。msg.data 必须为空</span><br><span class="line">      receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">      // 当 msg.data 不为空时调用 fallback 函数</span><br><span class="line">      fallback() external payable &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>现在我们将安装<code>dotenv</code>包以便能够导入 env 文件并在我们的配置中使用它。打开指向<code>hardhat-tutorial</code>目录的终端并执行此命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dotenv</span><br></pre></td></tr></table></figure><ul><li>现在在<code>hardhat-tutorial</code>文件夹中创建一个<code>.env</code>文件并添加以下行，使用注释中的说明获取您的 Alchemy API 密钥 URL 和 RINKEBY 私钥。确保您获得 rinkeby 私钥的帐户由 Rinkeby 以太币提供资金。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 转到 https://www.alchemyapi.io，注册，</span><br><span class="line">// 在其仪表板中创建一个新应用程序并选择网络为 Rinkeby，并将“add-the-alchemy-key-url-here”替换为其密钥 url</span><br><span class="line">ALCHEMY_API_KEY_URL=&quot;add-the-alchemy-key-url-here&quot;</span><br><span class="line"></span><br><span class="line">// 将此私钥替换为您的 RINKEBY 帐户私钥</span><br><span class="line">// 要从 Metamask 导出您的私钥，请打开 Metamask 并</span><br><span class="line">// 转到 Account Details &gt; Export Private Key</span><br><span class="line">// 请注意永远不要将真实的 Ether 放入测试帐户</span><br><span class="line">RINKEBY_PRIVATE_KEY=&quot;add-the-rinkeby-private-key-here&quot;</span><br></pre></td></tr></table></figure><ul><li><p>让我们将合约部署到<code>rinkeby</code>网络。创建一个新文件，或者替换在 scripts 文件夹下默认文件 deploy.js</p></li><li><p>现在我们将编写一些代码来在<code>deploy.js</code>文件中部署合约。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ethers &#125; = require(&quot;hardhat&quot;);</span><br><span class="line">require(&quot;dotenv&quot;).config(&#123; path: &quot;.env&quot; &#125;);</span><br><span class="line">const &#123; WHITELIST_CONTRACT_ADDRESS, METADATA_URL &#125; = require(&quot;../constants&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  // 您在上一个模块中部署的白名单合约的地址</span><br><span class="line">  const whitelistContract = WHITELIST_CONTRACT_ADDRESS;</span><br><span class="line">  // 我们可以从中提取 Crypto Dev NFT 元数据的 URL</span><br><span class="line">  const metadataURL = METADATA_URL;</span><br><span class="line">  /*</span><br><span class="line">  ethers.js 中的 ContractFactory 是用于部署新智能合约的抽象，</span><br><span class="line">  因此这里的 cryptoDevsContract 是我们的 CryptoDevs 合约实例的工厂。</span><br><span class="line">  */</span><br><span class="line">  const cryptoDevsContract = await ethers.getContractFactory(&quot;CryptoDevs&quot;);</span><br><span class="line"></span><br><span class="line">  // 部署合约</span><br><span class="line">  const deployedCryptoDevsContract = await cryptoDevsContract.deploy(</span><br><span class="line">    metadataURL,</span><br><span class="line">    whitelistContract</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // 打印部署合约的地址</span><br><span class="line">  console.log(</span><br><span class="line">    &quot;Crypto Devs Contract Address:&quot;,</span><br><span class="line">    deployedCryptoDevsContract.address</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用main函数，如果有错误就catch</span><br><span class="line">main()</span><br><span class="line">  .then(() =&gt; process.exit(0))</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>如您所见，<code>deploy.js</code>需要一些常量。让我们在<code>hardhat-tutorial</code>文件夹下创建一个名为<code>constants</code>的文件夹</p></li><li><p>现在在<code>constants</code>文件夹中添加一个<code>index.js</code>文件，并将以下行添加到文件中。将“address-of-the-whitelist-contract”替换为您在上一教程中部署的白名单合约的地址。对于 Metadata_URL，只需复制已提供的示例。我们将在教程中进一步替换它。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 您部署的白名单合约</span><br><span class="line">const WHITELIST_CONTRACT_ADDRESS = &quot;address-of-the-whitelist-contract&quot;;</span><br><span class="line">// 为 Crypto Dev NFT 提取元数据的 URL</span><br><span class="line">const METADATA_URL = &quot;https://nft-collection-sneh1999.vercel.app/api/&quot;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123; WHITELIST_CONTRACT_ADDRESS, METADATA_URL &#125;;</span><br></pre></td></tr></table></figure><ul><li>现在打开 hardhat.config.js 文件，我们将在<code>rinkeby</code>此处添加网络，以便我们可以将合约部署到 <code>rinkeby</code>。用下面给出的行替换<code>hardhat.config.js</code>文件中的所有行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);</span><br><span class="line">require(&quot;dotenv&quot;).config(&#123; path: &quot;.env&quot; &#125;);</span><br><span class="line"></span><br><span class="line">const ALCHEMY_API_KEY_URL = process.env.ALCHEMY_API_KEY_URL;</span><br><span class="line"></span><br><span class="line">const RINKEBY_PRIVATE_KEY = process.env.RINKEBY_PRIVATE_KEY;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  solidity: &quot;0.8.4&quot;,</span><br><span class="line">  networks: &#123;</span><br><span class="line">    rinkeby: &#123;</span><br><span class="line">      url: ALCHEMY_API_KEY_URL,</span><br><span class="line">      accounts: [RINKEBY_PRIVATE_KEY],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>编译合约，打开一个指向<code>hardhat-tutorial</code>目录的终端并执行这个命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><ul><li>要部署，请打开指向<code>hardhat-tutorial</code>目录的终端并执行此命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network rinkeby</span><br></pre></td></tr></table></figure><ul><li>将打印在终端上的 Crypto Devs Contract Address 保存在记事本中，您将在教程中进一步使用它。</li></ul><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><ul><li><p>为了开发网站，我们将使用<a href="https://reactjs.org/">React</a>和<a href="https://nextjs.org/">Next Js</a>.React 是一个用于制作网站的 javascript 框架，Next Js 构建在 React 之上。</p></li><li><p>首先，您需要创建一个新 next 应用程序。您的文件夹结构应该类似于</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- NFT-Collection</span><br><span class="line">       - hardhat-tutorial</span><br><span class="line">       - my-app</span><br></pre></td></tr></table></figure><ul><li>要创建<code>my-app</code>，请在终端指向 NFT-Collection 文件夹并键入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest</span><br></pre></td></tr></table></figure><p>并按下<code>enter</code>所有问题</p><ul><li>现在运行应用程序，在终端中执行这些命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><ul><li><p>现在转到<code>http://localhost:3000</code>，您的应用程序应该正在运行 🤘</p></li><li><p>现在让我们安装 Web3Modal 库（<a href="https://github.com/Web3Modal/web3modal%EF%BC%89%E3%80%82Web3Modal">https://github.com/Web3Modal/web3modal）。Web3Modal</a> 是一个易于使用的库，可帮助开发人员通过简单的可自定义配置在其应用程序中添加对多个提供程序的支持。默认情况下，Web3Modal 库支持注入的提供程序，例如（Metamask、Dapper、Gnosis Safe、Frame、Web3 浏览器等），您还可以轻松配置库以支持 Portis、Fortmatic、Squarelink、Torus、Authereum、D’CENT 钱包和 Arkane。打开指向<code>my-app</code>目录的终端并执行此命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3modal</span><br></pre></td></tr></table></figure><ul><li>在同一个终端也安装<code>ethers.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ethers</span><br></pre></td></tr></table></figure><ul><li><p>在您的公用文件夹中，下载此文件夹及其中的所有图像(<a href="https://download-directory.github.io/?url=https://github.com/LearnWeb3DAO/NFT-Collection/tree/main/my-app/public/cryptodevs">下载链接</a>)。确保下载的文件夹的名称是 <code>cryptodevs</code></p></li><li><p>现在转到样式文件夹并用以下代码替换<code>Home.modules.css</code>文件的所有内容，这将为您的 dapp 添加一些样式：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">  min-height: 90vh;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  font-family: &quot;Courier New&quot;, Courier, monospace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 2rem 0;</span><br><span class="line">  border-top: 1px solid #eaeaea;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.image &#123;</span><br><span class="line">  width: 70%;</span><br><span class="line">  height: 50%;</span><br><span class="line">  margin-left: 20%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title &#123;</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">  margin: 2rem 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.description &#123;</span><br><span class="line">  line-height: 1;</span><br><span class="line">  margin: 2rem 0;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">  border: none;</span><br><span class="line">  color: #ffffff;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  width: 200px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  margin-bottom: 2%;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 1000px) &#123;</span><br><span class="line">  .main &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打开 pages 文件夹下的 index.js 文件并粘贴以下代码，代码解释可以在评论中找到。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Contract, providers, utils &#125; from &quot;ethers&quot;;</span><br><span class="line">import Head from &quot;next/head&quot;;</span><br><span class="line">import React, &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;</span><br><span class="line">import Web3Modal from &quot;web3modal&quot;;</span><br><span class="line">import &#123; abi, NFT_CONTRACT_ADDRESS &#125; from &quot;../constants&quot;;</span><br><span class="line">import styles from &quot;../styles/Home.module.css&quot;;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line">  // walletConnected 跟踪用户的钱包是否连接</span><br><span class="line">  const [walletConnected, setWalletConnected] = useState(false);</span><br><span class="line">  // presaleStarted 跟踪预售是否已经开始</span><br><span class="line">  const [presaleStarted, setPresaleStarted] = useState(false);</span><br><span class="line">  // presaleEnded 跟踪预售是否结束</span><br><span class="line">  const [presaleEnded, setPresaleEnded] = useState(false);</span><br><span class="line">  // 当我们等待交易被挖掘时，loading 设置为 true</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  // 检查当前连接的 MetaMask 钱包是否是合约的所有者</span><br><span class="line">  const [isOwner, setIsOwner] = useState(false);</span><br><span class="line">  // tokenIdsMinted 跟踪已铸造的 tokenId 数量</span><br><span class="line">  const [tokenIdsMinted, setTokenIdsMinted] = useState(&quot;0&quot;);</span><br><span class="line">  // 创建对 Web3 模态（用于连接到 Metamask）的引用，只要页面打开，它就会持续存在</span><br><span class="line">  const web3ModalRef = useRef();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * presaleMint：在预售期间铸造 NFT</span><br><span class="line">   */</span><br><span class="line">  const presaleMint = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 我们需要一个签名者，因为这是一个“写入”交易。</span><br><span class="line">      const signer = await getProviderOrSigner(true);</span><br><span class="line">      // 创建一个带有签名者的合约的新实例，它允许更新方法</span><br><span class="line">      const whitelistContract = new Contract(</span><br><span class="line">        NFT_CONTRACT_ADDRESS,</span><br><span class="line">        abi,</span><br><span class="line">        signer</span><br><span class="line">      );</span><br><span class="line">      // 从合约中调用 presaleMint，只有列入白名单的地址才能铸币</span><br><span class="line">      const tx = await whitelistContract.presaleMint(&#123;</span><br><span class="line">        // value 表示一个加密开发者的成本，即“0.01”eth。</span><br><span class="line">        // 我们正在使用来自 ethers.js</span><br><span class="line">        value: utils.parseEther(&quot;0.01&quot;),</span><br><span class="line">      &#125;);</span><br><span class="line">      setLoading(true);</span><br><span class="line">      // 等待交易被挖掘</span><br><span class="line">      await tx.wait();</span><br><span class="line">      setLoading(false);</span><br><span class="line">      window.alert(&quot;You successfully minted a Crypto Dev!&quot;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * publicMint: 在预售后铸币 NFT</span><br><span class="line">   */</span><br><span class="line">  const publicMint = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 我们需要一个签名者，因为这是一个“写”交易。</span><br><span class="line">      const signer = await getProviderOrSigner(true);</span><br><span class="line">      // 创建一个带有签名者的合约的新实例，它允许更新方法</span><br><span class="line">      const whitelistContract = new Contract(</span><br><span class="line">        NFT_CONTRACT_ADDRESS,</span><br><span class="line">        abi,</span><br><span class="line">        signer</span><br><span class="line">      );</span><br><span class="line">      // 从合约调用铸币厂来铸币加密货币开发者</span><br><span class="line">      const tx = await whitelistContract.mint(&#123;</span><br><span class="line">        // value 表示一个加密货币开发者的成本，即“0.01”eth。</span><br><span class="line">        // 我们正在使用来自 ethers.js 的 utils 库将 `0.01` 字符串解析为 ether</span><br><span class="line">        value: utils.parseEther(&quot;0.01&quot;),</span><br><span class="line">      &#125;);</span><br><span class="line">      setLoading(true);</span><br><span class="line">      // 等待交易被挖掘</span><br><span class="line">      await tx.wait();</span><br><span class="line">      setLoading(false);</span><br><span class="line">      window.alert(&quot;You successfully minted a Crypto Dev!&quot;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">      connectWallet: 连接 MetaMask 钱包</span><br><span class="line">    */</span><br><span class="line">  const connectWallet = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 第一次使用时提示用户连接他们的钱包</span><br><span class="line">      await getProviderOrSigner();</span><br><span class="line">      setWalletConnected(true);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * startPresale：开始 NFT 集合的预售</span><br><span class="line">   */</span><br><span class="line">  const startPresale = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 我们需要一个签名者，因为这是一个“写”交易。</span><br><span class="line">      const signer = await getProviderOrSigner(true);</span><br><span class="line">      // 创建一个带有签名者的合约的新实例，它允许更新方法</span><br><span class="line">      const whitelistContract = new Contract(</span><br><span class="line">        NFT_CONTRACT_ADDRESS,</span><br><span class="line">        abi,</span><br><span class="line">        signer</span><br><span class="line">      );</span><br><span class="line">      // 从合约调用 startPresale</span><br><span class="line">      const tx = await whitelistContract.startPresale();</span><br><span class="line">      setLoading(true);</span><br><span class="line">      // 等待交易被挖掘</span><br><span class="line">      await tx.wait();</span><br><span class="line">      setLoading(false);</span><br><span class="line">      // 设置预售开始为真</span><br><span class="line">      await checkIfPresaleStarted();</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * checkIfPresaleStarted：通过查询合约中的 `presaleStarted`</span><br><span class="line">   * 变量来检查预售是否已经开始</span><br><span class="line">   */</span><br><span class="line">  const checkIfPresaleStarted = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 这里不需要签名者，因为我们只是从区块链中读取状态</span><br><span class="line">      const provider = await getProviderOrSigner();</span><br><span class="line">      // 我们使用提供者连接到合约，所以我们将只有</span><br><span class="line">      // 对合约拥有只读权限</span><br><span class="line">      const nftContract = new Contract(NFT_CONTRACT_ADDRESS, abi, provider);</span><br><span class="line">      // 从合约中调用 presaleStarted</span><br><span class="line">      const _presaleStarted = await nftContract.presaleStarted();</span><br><span class="line">      if (!_presaleStarted) &#123;</span><br><span class="line">        await getOwner();</span><br><span class="line">      &#125;</span><br><span class="line">      setPresaleStarted(_presaleStarted);</span><br><span class="line">      return _presaleStarted;</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * checkIfPresaleEnded: 通过查询合约中的 `presaleEnded`</span><br><span class="line">   * 变量检查预售是否结束</span><br><span class="line">   */</span><br><span class="line">  const checkIfPresaleEnded = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 这里不需要签名者，因为我们只是从区块链中读取状态</span><br><span class="line">      const provider = await getProviderOrSigner();</span><br><span class="line">      // 我们使用提供者连接到合约，所以我们将只有</span><br><span class="line">      // 对合约拥有只读权限</span><br><span class="line">      const nftContract = new Contract(NFT_CONTRACT_ADDRESS, abi, provider);</span><br><span class="line">      // 从合约中调用 presaleEnded</span><br><span class="line">      const _presaleEnded = await nftContract.presaleEnded();</span><br><span class="line">      // _presaleEnded 是一个大数字，所以我们使用 lt(小于函数) 而不是 `&lt;`</span><br><span class="line">      // Date.now()/1000 返回当前时间（以秒为单位）</span><br><span class="line">      // 我们比较 _presaleEnded 时间戳是否小于当前时间</span><br><span class="line">      // 这意味着预售已经结束</span><br><span class="line">      const hasEnded = _presaleEnded.lt(Math.floor(Date.now() / 1000));</span><br><span class="line">      if (hasEnded) &#123;</span><br><span class="line">        setPresaleEnded(true);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        setPresaleEnded(false);</span><br><span class="line">      &#125;</span><br><span class="line">      return hasEnded;</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * getOwner: 调用合约来获取所有者</span><br><span class="line">   */</span><br><span class="line">  const getOwner = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 这里不需要签名者，因为我们只是从区块链中读取状态</span><br><span class="line">      const provider = await getProviderOrSigner();</span><br><span class="line">      // 我们使用提供者连接到合约，所以我们将只有</span><br><span class="line">      // 对合约拥有只读权限</span><br><span class="line">      const nftContract = new Contract(NFT_CONTRACT_ADDRESS, abi, provider);</span><br><span class="line">      // 从合约中调用 owner 函数</span><br><span class="line">      const _owner = await nftContract.owner();</span><br><span class="line">      // 我们现在将获取签名者以提取当前连接的 MetaMask 帐户的地址</span><br><span class="line">      const signer = await getProviderOrSigner(true);</span><br><span class="line">      // 获取与 MetaMask 连接的签名者关联的地址</span><br><span class="line">      const address = await signer.getAddress();</span><br><span class="line">      if (address.toLowerCase() === _owner.toLowerCase()) &#123;</span><br><span class="line">        setIsOwner(true);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * getTokenIdsMinted: 获取已铸造的 tokenId 数量</span><br><span class="line">   */</span><br><span class="line">  const getTokenIdsMinted = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 这里不需要签名者，因为我们只是从区块链中读取状态</span><br><span class="line">      const provider = await getProviderOrSigner();</span><br><span class="line">      // 我们使用提供者连接到合约，所以我们将只有</span><br><span class="line">      // 对合约拥有只读权限</span><br><span class="line">      const nftContract = new Contract(NFT_CONTRACT_ADDRESS, abi, provider);</span><br><span class="line">      // 从合约中调用 tokenIds</span><br><span class="line">      const _tokenIds = await nftContract.tokenIds();</span><br><span class="line">      //_tokenIds 是一个“BigNumber”。我们需要将 Big Number 转换为字符串</span><br><span class="line">      setTokenIdsMinted(_tokenIds.toString());</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 返回代表以太坊 RPC 的 Provider 或 Signer 对象，带有或不带有</span><br><span class="line">   * 附加元掩码的签名功能</span><br><span class="line">   *</span><br><span class="line">   * 需要一个 `Provider` 来与区块链交互 - 读取交易、读取余额、读取状态等</span><br><span class="line">   *</span><br><span class="line">   * `Signer` 是一种特殊类型的 Provider，用于在需要对区块链进行`write` 交易的情况下，这涉及到连接的帐户</span><br><span class="line">   * 需要进行数字签名以授权正在发送的交易。Metamask 公开了一个 Signer API 以允许您的网站</span><br><span class="line">   * 使用 Signer 函数向用户请求签名。</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;*&#125; needSigner - 如果需要签名者则为真，否则默认为假</span><br><span class="line">   */</span><br><span class="line">  const getProviderOrSigner = async (needSigner = false) =&gt; &#123;</span><br><span class="line">    // 连接到 Metamask</span><br><span class="line">    // 因为我们存储 `web3Modal` 作为参考，我们需要访问 `current` 值来访问底层对象</span><br><span class="line">    const provider = await web3ModalRef.current.connect();</span><br><span class="line">    const web3Provider = new providers.Web3Provider(provider);</span><br><span class="line"></span><br><span class="line">    // 如果用户没有连接到 Rinkeby 网络，让他们知道并抛出错误</span><br><span class="line">    const &#123; chainId &#125; = await web3Provider.getNetwork();</span><br><span class="line">    if (chainId !== 4) &#123;</span><br><span class="line">      window.alert(&quot;Change the network to Rinkeby&quot;);</span><br><span class="line">      throw new Error(&quot;Change network to Rinkeby&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needSigner) &#123;</span><br><span class="line">      const signer = web3Provider.getSigner();</span><br><span class="line">      return signer;</span><br><span class="line">    &#125;</span><br><span class="line">    return web3Provider;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // useEffects 用于对网站状态的变化做出反应</span><br><span class="line">  // 函数调用末尾的数组表示什么状态变化会触发这个效果</span><br><span class="line">  // 在这种情况下，只要 `walletConnected` 的值发生变化 - 这个效果就会被称为</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 如果钱包没有连接，则创建一个新的 Web3Modal 实例并连接 MetaMask 钱包</span><br><span class="line">    if (!walletConnected) &#123;</span><br><span class="line">      // 通过将 Web3Modal 类设置为 `current` 将其分配给引用对象value</span><br><span class="line">      // 只要此页面打开，`current` 值就会一直保持</span><br><span class="line">      web3ModalRef.current = new Web3Modal(&#123;</span><br><span class="line">        network: &quot;rinkeby&quot;,</span><br><span class="line">        providerOptions: &#123;&#125;,</span><br><span class="line">        disableInjectedProvider: false,</span><br><span class="line">      &#125;);</span><br><span class="line">      connectWallet();</span><br><span class="line"></span><br><span class="line">      // 检查预售是否已经开始和结束</span><br><span class="line">      const _presaleStarted = checkIfPresaleStarted();</span><br><span class="line">      if (_presaleStarted) &#123;</span><br><span class="line">        checkIfPresaleEnded();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      getTokenIdsMinted();</span><br><span class="line"></span><br><span class="line">      // 设置每 5 秒调用一次的时间间隔，以检查预售是否结束</span><br><span class="line">      const presaleEndedInterval = setInterval(async function () &#123;</span><br><span class="line">        const _presaleStarted = await checkIfPresaleStarted();</span><br><span class="line">        if (_presaleStarted) &#123;</span><br><span class="line">          const _presaleEnded = await checkIfPresaleEnded();</span><br><span class="line">          if (_presaleEnded) &#123;</span><br><span class="line">            clearInterval(presaleEndedInterval);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, 5 * 1000);</span><br><span class="line"></span><br><span class="line">      // 设置间隔以获取每 5 秒生成的令牌 Id 的数量</span><br><span class="line">      setInterval(async function () &#123;</span><br><span class="line">        await getTokenIdsMinted();</span><br><span class="line">      &#125;, 5 * 1000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [walletConnected]);</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">      renderButton: 根据 dapp 的状态返回一个按钮</span><br><span class="line">    */</span><br><span class="line">  const renderButton = () =&gt; &#123;</span><br><span class="line">    // 如果钱包没有连接，返回一个允许他们连接钱包的按钮</span><br><span class="line">    if (!walletConnected) &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;button onClick=&#123;connectWallet&#125; className=&#123;styles.button&#125;&gt;</span><br><span class="line">          Connect your wallet</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果我们当前正在等待某些东西，返回一个加载按钮</span><br><span class="line">    if (loading) &#123;</span><br><span class="line">      return &lt;button className=&#123;styles.button&#125;&gt;Loading...&lt;/button&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果连接的用户是所有者，并且预售还没有开始，允许他们开始预售</span><br><span class="line">    if (isOwner &amp;&amp; !presaleStarted) &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;button className=&#123;styles.button&#125; onClick=&#123;startPresale&#125;&gt;</span><br><span class="line">          Start Presale!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果连接的用户不是所有者但预售还没有开始，告诉他们</span><br><span class="line">    if (!presaleStarted) &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;Presale hasnt started!&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果预售开始，但尚未结束，允许在预售期间进行铸币</span><br><span class="line">    if (presaleStarted &amp;&amp; !presaleEnded) &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;</span><br><span class="line">            Presale has started!!! If your address is whitelisted, Mint a</span><br><span class="line">            Crypto Dev 🥳</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;button className=&#123;styles.button&#125; onClick=&#123;presaleMint&#125;&gt;</span><br><span class="line">            Presale Mint 🚀</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果预售开始并结束，则公开铸币的时间</span><br><span class="line">    if (presaleStarted &amp;&amp; presaleEnded) &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;button className=&#123;styles.button&#125; onClick=&#123;publicMint&#125;&gt;</span><br><span class="line">          Public Mint 🚀</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;Crypto Devs&lt;/title&gt;</span><br><span class="line">        &lt;meta name=&quot;description&quot; content=&quot;Whitelist-Dapp&quot; /&gt;</span><br><span class="line">        &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;</span><br><span class="line">      &lt;/Head&gt;</span><br><span class="line">      &lt;div className=&#123;styles.main&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1 className=&#123;styles.title&#125;&gt;Welcome to Crypto Devs!&lt;/h1&gt;</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;</span><br><span class="line">            Its an NFT collection for developers in Crypto.</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;</span><br><span class="line">            &#123;tokenIdsMinted&#125;/20 have been minted</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &#123;renderButton()&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;img className=&#123;styles.image&#125; src=&quot;./cryptodevs/0.svg&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;footer className=&#123;styles.footer&#125;&gt;</span><br><span class="line">        Made with &amp;#10084; by Crypto Devs</span><br><span class="line">      &lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>现在在 my-app 文件夹下创建一个新文件夹并将其命名为<code>constants</code>.</p></li><li><p>在 constants 文件夹中创建一个文件<code>index.js</code>，然后粘贴以下代码。</p><ul><li>替换<code>&quot;addres of your NFT contract&quot;</code>为您部署并保存到记事本的 CryptoDevs 合约的地址。</li><li>替换<code>---your abi---</code>为您的 CryptoDevs 合约的 abi。要获取您的合同的 abi，​​ 请转到您的<code>hardhat-tutorial/artifacts/contracts/CryptoDevs.sol</code>文件夹并从您的<code>CryptoDevs.json</code>文件中获取标记在<code>&quot;abi&quot;</code>密钥下的数组。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const abi =---your abi---</span><br><span class="line">export const NFT_CONTRACT_ADDRESS = &quot;address of your NFT contract&quot;</span><br></pre></td></tr></table></figure><ul><li>现在在指向<code>my-app</code>文件夹的终端中，执行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>您的 Crypto Devs NFT dapp 现在应该可以正常运行了 🚀</p><hr><h2 id="推送到-github"><a href="#推送到-github" class="headerlink" title="推送到 github"></a>推送到 github</h2><p>确保在继续之前您已将<a href="https://medium.com/hackernoon/a-gentle-introduction-to-git-and-github-the-eli5-way-43f0aa64f2e4">所有代码推送到 github</a> :)</p><hr><h2 id="部署你的-dApp"><a href="#部署你的-dApp" class="headerlink" title="部署你的 dApp"></a>部署你的 dApp</h2><p>我们现在将部署您的 dApp，以便每个人都可以看到您的网站，并且您可以与所有 LearnWeb3 DAO 朋友分享它。</p><ul><li>转到<a href="https://vercel.com/">https://vercel.com/</a> 并使用您的 GitHub 登录</li><li>然后单击<code>New Project</code>按钮，然后选择您的 NFT-Collection 存储库</li><li>在配置您的新项目时，Vercel 将允许您自定义您的<code>Root Directory</code></li><li>单击<code>Edit</code>旁边<code>Root Directory</code>并将其设置为<code>my-app</code></li><li>选择框架为<code>Next.js</code></li><li>单击部署</li></ul><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level9/2.png?raw=true"></p><ul><li>现在，您可以通过转到仪表板、选择您的项目并<code>domain</code>从那里复制来查看您部署的网站！保存<code>domain</code>在记事本上，稍后您将需要它。</li></ul><h2 id="在-Opensea-上查看您的收藏"><a href="#在-Opensea-上查看您的收藏" class="headerlink" title="在 Opensea 上查看您的收藏"></a>在 Opensea 上查看您的收藏</h2><p>现在让您的收藏在 Opensea 上可用</p><p>为了使该集合在 Opensea 上可用，我们需要创建一个元数据端点。该端点将返回给定 NFT 的元数据<code>tokenId</code>。</p><ul><li>打开您的<code>my-app</code>文件夹并在<code>pages/api</code>文件夹下创建一个名为的新文件<code>[tokenId].js</code>(确保名称也包含括号). 添加括号有助于<a href="https://nextjs.org/docs/routing/dynamic-routes">next js</a>中创建动态路由</li><li>将以下行添加到<code>[tokenId].js</code>文件中。在<a href="https://nextjs.org/docs/api-routes/introduction">here</a>阅读有关添加<code>next js</code>API 路由的信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default function handler(req, res) &#123;</span><br><span class="line">  // 从查询参数中获取 tokenId</span><br><span class="line">  const tokenId = req.query.tokenId;</span><br><span class="line">  // 由于所有图片都是在github上上传的，我们可以直接从github中提取图片。</span><br><span class="line">  const image_url =</span><br><span class="line">    &quot;https://raw.githubusercontent.com/LearnWeb3DAO/NFT-Collection/main/my-app/public/cryptodevs/&quot;;</span><br><span class="line">  // api 正在为 Crypto Dev 发回元数据</span><br><span class="line">  // 为了使我们的集合与 Opensea 兼容，我们需要遵循一些元数据标准</span><br><span class="line">  // 当从 api 发回响应时</span><br><span class="line">  // 更多信息可以在这里找到：https://docs.opensea.io/docs/metadata-standards</span><br><span class="line">  res.status(200).json(&#123;</span><br><span class="line">    name: &quot;Crypto Dev #&quot; + tokenId,</span><br><span class="line">    description: &quot;Crypto Dev is a collection of developers in crypto&quot;,</span><br><span class="line">    image: image_url + tokenId + &quot;.svg&quot;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>现在你有一个 api 路由，<code>Opensea</code>可以调用它来检索 NFT 的元数据</li><li>让我们用这个新的 api 路由部署一个新<code>Crypto Devs</code>合约作为你的<code>METADATA_URL</code></li><li>打开您的<code>hardhat-tutorial/constants</code>文件夹并在您的<code>index.js</code>文件中，将”<a href="https://nft-collection-sneh1999.vercel.app/api/%22%E6%9B%BF%E6%8D%A2%E4%B8%BA%E6%82%A8%E4%BF%9D%E5%AD%98%E5%88%B0%E8%AE%B0%E4%BA%8B%E6%9C%AC%E7%9A%84%E5%9F%9F%EF%BC%8C%E5%B9%B6%E5%9C%A8%E5%85%B6%E6%9C%AB%E5%B0%BE%E6%B7%BB%E5%8A%A0%22/api/%22%E3%80%82">https://nft-collection-sneh1999.vercel.app/api/&quot;替换为您保存到记事本的域，并在其末尾添加&quot;/api/&quot;。</a></li><li>保存文件并打开一个指向<code>hardhat-tutorial</code>文件夹的新终端并部署新合约</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network rinkeby</span><br></pre></td></tr></table></figure><ul><li>将新的 NFT 合约地址保存到记事本中。</li><li>打开”my-app&#x2F;constants”文件夹，在<code>index.js</code>文件中将旧的 NFT 合约地址替换为新的</li><li>将所有代码推送到 github，等待 vercel 部署新代码。</li><li>在 vercel 部署你的代码后，打开你的网站并铸造一个 NFT</li><li>交易成功后，在浏览器中打开此链接，替换<code>your-nft-contract-address</code>为您的 NFT 合约地址(<a href="https://testnets.opensea.io/assets/your-nft-contract-address/1">https://testnets.opensea.io/assets/your-nft-contract-address/1</a>)</li><li>你的 NFT 现在可以在 Opensea 上使用 🚀 🥳</li><li>在 discord 上与所有人分享您的 Opensea 链接 :) 并传播快乐。</li></ul>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>白名单-Dapp</title>
    <link href="http://blog.julysong.com/2022/09/01/web3-sophomore-level8/"/>
    <id>http://blog.julysong.com/2022/09/01/web3-sophomore-level8/</id>
    <published>2022-09-01T07:47:18.000Z</published>
    <updated>2025-02-20T06:39:02.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/acd04999-1230-4533-b6de-6b4e4978914c">Whitelist-Dapp</a></p><p>翻译: JulySong</p></blockquote><p>您正在启动名为<code>Crypto Devs</code>. 你想让你的早期支持者访问你收藏的白名单，所以在这里你要创建一个白名单 dapp<code>Crypto Devs</code></p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level8/1.png?raw=true"></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>名单访问权应该<code>10</code>免费提供给想要进入的第一批用户。</li><li>应该有一个网站，人们可以进入白名单。</li></ul><p>让我们开始建造 🚀</p><hr><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>您可以使用 JavaScript 编写代码 (Beginner Track - <a href="https://github.com/LearnWeb3DAO/Basic-Programming">Level-0</a>)</li><li>已设置 Metamask 钱包 (Beginner Track - <a href="https://github.com/LearnWeb3DAO/Crypto-Wallets">Level-4</a>)</li><li>您的计算机已安装 Node.js。如果不是从 <a href="https://nodejs.org/en/download/">here</a></li></ul><hr><h2 id="喜欢视频？"><a href="#喜欢视频？" class="headerlink" title="喜欢视频？"></a>喜欢视频？</h2><p>如果您想从视频中学习，我们的 YouTube 上有本教程的录音。单击下面的屏幕截图观看视频，或继续阅读教程！</p><p><a href="https://www.youtube.com/watch?v=eSS0vZ7rqpU&t=4757s">视频 1</a></p><p><a href="https://www.youtube.com/watch?v=iMOAUkL09pU">视频 2</a></p><h2 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>为了构建智能合约，我们将使用 <a href="https://hardhat.org/">Hardhat</a>. Hardhat 是一个以太坊开发环境和框架，专为 Solidity 中的全栈开发而设计。简单来说，您可以编写智能合约、部署它们、运行测试和调试代码。</p><ul><li>首先，您需要创建一个 Whitelist-Daap 文件夹，Hardhat 项目和您的 Next.js 应用程序稍后将进入该文件夹</li><li>打开终端并执行这些命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir Whitelist-Dapp</span><br><span class="line">cd Whitelist-Dapp</span><br></pre></td></tr></table></figure><ul><li>然后，在 Whitelist-Daap 文件夹中，您将设置 Hardhat 项目</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir hardhat-tutorial</span><br><span class="line">cd hardhat-tutorial</span><br><span class="line">npm init --yes</span><br><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure><ul><li>在安装 Hardhat 的同一目录中运行：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></table></figure><pre><code>- Select `Create a Javascript project`- Press enter for the already specified `Hardhat Project root`- Press enter for the question on if you want to add a `.gitignore`- Press enter for `Do you want to install this sample project&#39;s dependencies with npm (@nomicfoundation/hardhat-toolbox)?`</code></pre><p>现在你有一个安全帽项目准备好了！</p><p>如果您不在 Mac 上，请执行此额外步骤并安装这些库：)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure><ul><li>首先在<code>contracts</code>文件夹下创建一个名为<code>Whitelist.sol</code>的文件.</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: Unlicense</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Whitelist &#123;</span><br><span class="line"></span><br><span class="line">    // 允许的最大白名单地址数</span><br><span class="line">    uint8 public maxWhitelistedAddresses;</span><br><span class="line"></span><br><span class="line">    // 创建 whitelistedAddresses 的映射</span><br><span class="line">    // 如果地址被列入白名单，我们会将其设置为 true，对于所有其他地址默认为 false。</span><br><span class="line">    mapping(address =&gt; bool) public whitelistedAddresses;</span><br><span class="line"></span><br><span class="line">    // numAddressesWhitelisted 将用于跟踪有多少地址被列入白名单</span><br><span class="line">    // 注意：不要更改此变量名，因为它将是验证的一部分</span><br><span class="line">    uint8 public numAddressesWhitelisted;</span><br><span class="line"></span><br><span class="line">    // 设置白名单地址的最大数量</span><br><span class="line">    // 用户将在部署时放置该值</span><br><span class="line">    constructor(uint8 _maxWhitelistedAddresses) &#123;</span><br><span class="line">        maxWhitelistedAddresses =  _maxWhitelistedAddresses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">        addAddressToWhitelist - 此函数将发送者的地址添加到白名单</span><br><span class="line">     */</span><br><span class="line">    function addAddressToWhitelist() public &#123;</span><br><span class="line">        // 检查用户是否已被列入白名单</span><br><span class="line">        require(!whitelistedAddresses[msg.sender], &quot;Sender has already been whitelisted&quot;);</span><br><span class="line">        // 检查是否 numAddressesWhitelisted &lt; maxWhitelistedAddresses，如果不是则抛出错误。</span><br><span class="line">        require(numAddressesWhitelisted &lt; maxWhitelistedAddresses, &quot;More addresses cant be added, limit reached&quot;);</span><br><span class="line">        // 将调用函数的地址添加到 whitelistedAddress 数组</span><br><span class="line">        whitelistedAddresses[msg.sender] = true;</span><br><span class="line">        // 增加白名单地址数量</span><br><span class="line">        numAddressesWhitelisted += 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>让我们将合约部署到<code>rinkeby</code>网络。创建一个新文件，或者替换文件夹<code>scripts</code>下命名的默认文件<code>deploy.js</code></p></li><li><p>现在我们将编写一些代码来在<code>deploy.js</code>文件中部署合约。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ethers &#125; = require(&quot;hardhat&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  /*</span><br><span class="line">  ethers.js 中的 ContractFactory 是用于部署新智能合约的抽象，</span><br><span class="line">  所以 whitelistContract 这里是我们白名单合约实例的工厂。</span><br><span class="line">  */</span><br><span class="line">  const whitelistContract = await ethers.getContractFactory(&quot;Whitelist&quot;);</span><br><span class="line"></span><br><span class="line">  // 这里我们部署合约</span><br><span class="line">  const deployedWhitelistContract = await whitelistContract.deploy(10);</span><br><span class="line">  // 10 是允许的最大白名单地址数</span><br><span class="line"></span><br><span class="line">  // 等待它完成部署</span><br><span class="line">  await deployedWhitelistContract.deployed();</span><br><span class="line"></span><br><span class="line">  // 打印部署合约的地址</span><br><span class="line">  console.log(</span><br><span class="line">    &quot;Whitelist Contract Address:&quot;,</span><br><span class="line">    deployedWhitelistContract.address</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用main函数，如果有错误就catch</span><br><span class="line">main()</span><br><span class="line">  .then(() =&gt; process.exit(0))</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ul><li>现在在<code>hardhat-tutorial</code>文件夹中创建一个<code>.env</code>文件并添加以下行，使用注释中的说明获取您的 Alchemy API key URL 和 RINKEBY Private Key。确保您获得 rinkeby 私钥的帐户由 Rinkeby 以太币提供资金。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 转到 https://www.alchemyapi.io, 注册，</span><br><span class="line">//在其仪表板中创建一个新应用程序并选择网络为 Rinkeby，并将“add-the-alchemy-key-url-here”替换为其密钥 url its key url</span><br><span class="line">ALCHEMY_API_KEY_URL=&quot;add-the-alchemy-key-url-here&quot;</span><br><span class="line"></span><br><span class="line">// 将此私钥替换为您的 RINKEBY 帐户私钥</span><br><span class="line">// 要从 Metamask 导出您的私钥，请打开 Metamask 并</span><br><span class="line">// 转到 Account Details &gt; Export Private Key</span><br><span class="line">// 请注意永远不要将真实的 Ether 放入测试帐户</span><br><span class="line">RINKEBY_PRIVATE_KEY=&quot;add-the-rinkeby-private-key-here&quot;</span><br></pre></td></tr></table></figure><ul><li>现在我们将安装<code>dotenv</code>包以便能够导入 env 文件并在我们的配置中使用它。打开指向<code>hardhat-tutorial</code>目录的终端并执行此命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dotenv</span><br></pre></td></tr></table></figure><ul><li>现在打开 hardhat.config.js 文件，我们将在此处添加<code>rinkeby</code>网络，以便我们可以将合约部署到 rinkeby。用下面给出的行替换<code>hardhar.config.js</code>文件中的所有行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);</span><br><span class="line">require(&quot;dotenv&quot;).config(&#123; path: &quot;.env&quot; &#125;);</span><br><span class="line"></span><br><span class="line">const ALCHEMY_API_KEY_URL = process.env.ALCHEMY_API_KEY_URL;</span><br><span class="line"></span><br><span class="line">const RINKEBY_PRIVATE_KEY = process.env.RINKEBY_PRIVATE_KEY;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  solidity: &quot;0.8.9&quot;,</span><br><span class="line">  networks: &#123;</span><br><span class="line">    rinkeby: &#123;</span><br><span class="line">      url: ALCHEMY_API_KEY_URL,</span><br><span class="line">      accounts: [RINKEBY_PRIVATE_KEY],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>编译合约，打开一个指向 hardhat-tutorial 目录的终端并执行这个命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><ul><li>要部署，请打开指向<code>hardhat-tutorial</code>目录的终端并执行此命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network rinkeby</span><br></pre></td></tr></table></figure><p>将打印在终端上的白名单合约地址保存在记事本中，您将在教程中进一步使用它。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><ul><li><p>为了开发网站，我们将使用 React 和 Next Js。React 是一个用于制作网站的 javascript 框架，Next.js 是一个 React 框架，它还允许与前端一起编写后端 API 代码，因此您不需要两个单独的前端和后端服务。</p></li><li><p>首先，您需要创建一个新<code>next</code>应用程序。</p></li><li><p>要创建它<code>next-app</code>，在终端指向 Whitelist-Dapp 文件夹并输入</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app@latest</span><br></pre></td></tr></table></figure><p>并按下<code>enter</code>所有问题</p><ul><li>您的文件夹结构应该类似于</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Whitelist-Dapp</span><br><span class="line">    - hardhat-tutorial</span><br><span class="line">    - my-app</span><br></pre></td></tr></table></figure><ul><li>现在运行应用程序，在终端中执行这些命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my-app</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><ul><li><p>现在转到<code>http://localhost:3000</code>，您的应用程序应该正在运行 🤘</p></li><li><p>现在让我们安装<a href="https://github.com/Web3Modal/web3modal">Web3Modal library</a>。Web3Modal 是一个易于使用的库，可帮助开发人员轻松地让他们的用户使用各种不同的钱包连接到您的 dApp。默认情况下，Web3Modal 库支持注入的提供程序，如（Metamask、Dapper、Gnosis Safe、Frame、Web3 浏览器等）和 WalletConnect，您还可以轻松配置库以支持 Portis、Fortmatic、Squarelink、Torus、Authereum、D’CENT 钱包和阿卡内。（这是<a href="https://codesandbox.io/s/j43b10">Codesandbox.io</a>上的一个活生生的例子）</p></li><li><p>打开指向<code>my-app</code>目录的终端并执行此命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install web3modal</span><br></pre></td></tr></table></figure><ul><li>在同一个终端也安装<code>ethers.js</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install ethers</span><br></pre></td></tr></table></figure><ul><li><p>在您的 my-app&#x2F;public 文件夹中，下载<a href="https://github.com/LearnWeb3DAO/Whitelist-Dapp/blob/main/my-app/public/crypto-devs.svg">此图像</a>并将其重命名为<code>crypto-devs.svg</code></p></li><li><p>现在转到样式文件夹并用<code>Home.modules.css</code>以下代码替换文件的所有内容，这将为您的 dapp 添加一些样式：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">.main &#123;</span><br><span class="line">  min-height: 90vh;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: row;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  font-family: &quot;Courier New&quot;, Courier, monospace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 2rem 0;</span><br><span class="line">  border-top: 1px solid #eaeaea;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.image &#123;</span><br><span class="line">  width: 70%;</span><br><span class="line">  height: 50%;</span><br><span class="line">  margin-left: 20%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title &#123;</span><br><span class="line">  font-size: 2rem;</span><br><span class="line">  margin: 2rem 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.description &#123;</span><br><span class="line">  line-height: 1;</span><br><span class="line">  margin: 2rem 0;</span><br><span class="line">  font-size: 1.2rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  background-color: blue;</span><br><span class="line">  border: none;</span><br><span class="line">  color: #ffffff;</span><br><span class="line">  font-size: 15px;</span><br><span class="line">  padding: 20px;</span><br><span class="line">  width: 200px;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">  margin-bottom: 2%;</span><br><span class="line">&#125;</span><br><span class="line">@media (max-width: 1000px) &#123;</span><br><span class="line">  .main &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>打开 pages 文件夹下的 index.js 文件并粘贴以下代码，代码解释可以在评论中找到。如果您不熟悉 React 和<a href="https://reactjs.org/docs/hooks-overview.html">React Hooks</a>和<a href="https://www.w3schools.com/react/react_hooks.asp">React Hooks Tutorial</a>，请务必阅读它们。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line">import Head from &quot;next/head&quot;;</span><br><span class="line">import styles from &quot;../styles/Home.module.css&quot;;</span><br><span class="line">import Web3Modal from &quot;web3modal&quot;;</span><br><span class="line">import &#123; providers, Contract &#125; from &quot;ethers&quot;;</span><br><span class="line">import &#123; useEffect, useRef, useState &#125; from &quot;react&quot;;</span><br><span class="line">import &#123; WHITELIST_CONTRACT_ADDRESS, abi &#125; from &quot;../constants&quot;;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line">  // walletConnected 跟踪用户的钱包是否连接</span><br><span class="line">  const [walletConnected, setWalletConnected] = useState(false);</span><br><span class="line">  // joinedWhitelist 跟踪当前元掩码地址是否加入白名单</span><br><span class="line">  const [joinedWhitelist, setJoinedWhitelist] = useState(false);</span><br><span class="line">  // 当我们等待交易被挖掘时，loading 设置为 true</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line">  // numberOfWhitelisted 跟踪地址的白名单数量</span><br><span class="line">  const [numberOfWhitelisted, setNumberOfWhitelisted] = useState(0);</span><br><span class="line">  // 创建对 Web3 Modal 的引用（用于连接到 Metamask），只要页面打开，它就会一直存在</span><br><span class="line">  const web3ModalRef = useRef();</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 返回代表以太坊 RPC 的 Provider 或 Signer 对象，带有或不带有</span><br><span class="line">   * 附加元掩码的签名功能</span><br><span class="line">   *</span><br><span class="line">   * 需要一个 `Provider` 来与区块链交互 - 读取交易、读取余额、读取状态等</span><br><span class="line">   *</span><br><span class="line">   * `Signer` 是一种特殊类型的 Provider，用于在需要对区块链进行`write` 交易的情况下，这涉及到连接的帐户</span><br><span class="line">   * 需要进行数字签名以授权正在发送的交易。Metamask 公开了一个 Signer API 以允许您的网站</span><br><span class="line">   * 使用 Signer 函数向用户请求签名。</span><br><span class="line">   *</span><br><span class="line">   * @param &#123;*&#125; needSigner - 如果需要签名者则为真，否则默认为假</span><br><span class="line">   */</span><br><span class="line">  const getProviderOrSigner = async (needSigner = false) =&gt; &#123;</span><br><span class="line">    // 连接到 Metamask</span><br><span class="line">    // 因为我们存储 `web3Modal` 作为参考，我们需要访问 `current` 值来访问底层对象</span><br><span class="line">    const provider = await web3ModalRef.current.connect();</span><br><span class="line">    const web3Provider = new providers.Web3Provider(provider);</span><br><span class="line"></span><br><span class="line">    // 如果用户没有连接到 Rinkeby 网络，让他们知道并抛出错误</span><br><span class="line">    const &#123; chainId &#125; = await web3Provider.getNetwork();</span><br><span class="line">    if (chainId !== 4) &#123;</span><br><span class="line">      window.alert(&quot;Change the network to Rinkeby&quot;);</span><br><span class="line">      throw new Error(&quot;Change network to Rinkeby&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (needSigner) &#123;</span><br><span class="line">      const signer = web3Provider.getSigner();</span><br><span class="line">      return signer;</span><br><span class="line">    &#125;</span><br><span class="line">    return web3Provider;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * addAddressToWhitelist：将当前连接的地址添加到白名单</span><br><span class="line">   */</span><br><span class="line">  const addAddressToWhitelist = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 我们在这里需要一个签名者，因为这是一个“写入”事务。</span><br><span class="line">      const signer = await getProviderOrSigner(true);</span><br><span class="line">      // 使用 Signer 创建一个新的 Contract 实例，它允许</span><br><span class="line">      // 更新方法</span><br><span class="line">      const whitelistContract = new Contract(</span><br><span class="line">        WHITELIST_CONTRACT_ADDRESS,</span><br><span class="line">        abi,</span><br><span class="line">        signer</span><br><span class="line">      );</span><br><span class="line">      // 从合约中调用 addAddressToWhitelist</span><br><span class="line">      const tx = await whitelistContract.addAddressToWhitelist();</span><br><span class="line">      setLoading(true);</span><br><span class="line">      // 等待交易被挖掘</span><br><span class="line">      await tx.wait();</span><br><span class="line">      setLoading(false);</span><br><span class="line">      // 获取更新后的白名单地址数</span><br><span class="line">      await getNumberOfWhitelisted();</span><br><span class="line">      setJoinedWhitelist(true);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * getNumberOfWhitelisted: 获取白名单地址的数量</span><br><span class="line">   */</span><br><span class="line">  const getNumberOfWhitelisted = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 这里不需要签名者，因为我们仅从区块链中读取状态</span><br><span class="line">      const provider = await getProviderOrSigner();</span><br><span class="line">      // 我们使用提供者连接到合约，因此我们将只有</span><br><span class="line">      // 对合约拥有只读权限</span><br><span class="line">      const whitelistContract = new Contract(</span><br><span class="line">        WHITELIST_CONTRACT_ADDRESS,</span><br><span class="line">        abi,</span><br><span class="line">        provider</span><br><span class="line">      );</span><br><span class="line">      // 从合约中调用 numAddressesWhitelisted</span><br><span class="line">      const _numberOfWhitelisted = await whitelistContract.numAddressesWhitelisted();</span><br><span class="line">      setNumberOfWhitelisted(_numberOfWhitelisted);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * checkIfAddressInWhitelist: 检查地址是否在白名单中</span><br><span class="line">   */</span><br><span class="line">  const checkIfAddressInWhitelist = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 我们稍后需要签名者来获取用户的地址</span><br><span class="line">      // 即使它是一个读交易，因为签名者只是特殊类型的提供者，</span><br><span class="line">      // 我们可以在它的位置使用它</span><br><span class="line">      const signer = await getProviderOrSigner(true);</span><br><span class="line">      const whitelistContract = new Contract(</span><br><span class="line">        WHITELIST_CONTRACT_ADDRESS,</span><br><span class="line">        abi,</span><br><span class="line">        signer</span><br><span class="line">      );</span><br><span class="line">      // 获取与 MetaMask 连接的签名者关联的地址</span><br><span class="line">      const address = await signer.getAddress();</span><br><span class="line">      // 从合约中调用 whitelistedAddresses</span><br><span class="line">      const _joinedWhitelist = await whitelistContract.whitelistedAddresses(</span><br><span class="line">        address</span><br><span class="line">      );</span><br><span class="line">      setJoinedWhitelist(_joinedWhitelist);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    connectWallet: 连接 MetaMask 钱包</span><br><span class="line">  */</span><br><span class="line">  const connectWallet = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 从 web3Modal 获取提供者，在我们的例子中是 MetaMask</span><br><span class="line">      // 第一次使用时提示用户连接他们的钱包</span><br><span class="line">      await getProviderOrSigner();</span><br><span class="line">      setWalletConnected(true);</span><br><span class="line"></span><br><span class="line">      checkIfAddressInWhitelist();</span><br><span class="line">      getNumberOfWhitelisted();</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">    renderButton: 根据 dapp 的状态返回一个按钮</span><br><span class="line">  */</span><br><span class="line">  const renderButton = () =&gt; &#123;</span><br><span class="line">    if (walletConnected) &#123;</span><br><span class="line">      if (joinedWhitelist) &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;</span><br><span class="line">            Thanks for joining the Whitelist!</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125; else if (loading) &#123;</span><br><span class="line">        return &lt;button className=&#123;styles.button&#125;&gt;Loading...&lt;/button&gt;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;button onClick=&#123;addAddressToWhitelist&#125; className=&#123;styles.button&#125;&gt;</span><br><span class="line">            Join the Whitelist</span><br><span class="line">          &lt;/button&gt;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;button onClick=&#123;connectWallet&#125; className=&#123;styles.button&#125;&gt;</span><br><span class="line">          Connect your wallet</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // useEffects 用于对网站状态的变化做出反应</span><br><span class="line">  // 函数调用末尾的数组表示什么状态变化会触发这个效果</span><br><span class="line">  // 在这种情况下，只要 `walletConnected` 的值发生变化 - 这个效果就会被称为</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 如果钱包没有连接，则创建一个新的 Web3Modal 实例并连接 MetaMask 钱包</span><br><span class="line">    if (!walletConnected) &#123;</span><br><span class="line">      // 通过将 Web3Modal 类设置为 `current` 将其分配给引用对象value</span><br><span class="line">      // 只要此页面打开，`current` 值就会一直保持</span><br><span class="line">      web3ModalRef.current = new Web3Modal(&#123;</span><br><span class="line">        network: &quot;rinkeby&quot;,</span><br><span class="line">        providerOptions: &#123;&#125;,</span><br><span class="line">        disableInjectedProvider: false,</span><br><span class="line">      &#125;);</span><br><span class="line">      connectWallet();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [walletConnected]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Head&gt;</span><br><span class="line">        &lt;title&gt;Whitelist Dapp&lt;/title&gt;</span><br><span class="line">        &lt;meta name=&quot;description&quot; content=&quot;Whitelist-Dapp&quot; /&gt;</span><br><span class="line">        &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt;</span><br><span class="line">      &lt;/Head&gt;</span><br><span class="line">      &lt;div className=&#123;styles.main&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h1 className=&#123;styles.title&#125;&gt;Welcome to Crypto Devs!&lt;/h1&gt;</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;</span><br><span class="line">            Its an NFT collection for developers in Crypto.</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div className=&#123;styles.description&#125;&gt;</span><br><span class="line">            &#123;numberOfWhitelisted&#125; have already joined the Whitelist</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &#123;renderButton()&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;img className=&#123;styles.image&#125; src=&quot;./crypto-devs.svg&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;footer className=&#123;styles.footer&#125;&gt;</span><br><span class="line">        Made with &amp;#10084; by Crypto Devs</span><br><span class="line">      &lt;/footer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>现在在 my-app 文件夹下创建一个新文件夹并将其命名为<code>constants</code>。</p></li><li><p>在常量文件夹中创建一个文件<code>index.js</code>，然后粘贴以下代码。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const WHITELIST_CONTRACT_ADDRESS = &quot;YOUR_WHITELIST_CONTRACT_ADDRESS&quot;;</span><br><span class="line">export const abi = YOUR_ABI;</span><br></pre></td></tr></table></figure><ul><li><p>替换<code>&quot;YOUR_WHITELIST_CONTRACT_ADDRESS&quot;</code>为您部署的白名单合约的地址。</p></li><li><p>替换<code>&quot;YOUR_ABI&quot;</code>为您的白名单合约的 ABI。要为您的合同获取 ABI，请转到您的<code>hardhat-tutorial/artifacts/contracts/Whitelist.sol</code>文件夹并从您的<code>Whitelist.json</code>文件中获取标记在<code>&quot;abi&quot;</code>密钥下的数组（这将是一个巨大的数组，如果不是更多的话，接近 100 行）。</p></li><li><p>现在在指向<code>my-app</code>文件夹的终端中，执行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>您的白名单 dapp 现在应该可以正常运行了 🚀</p><h3 id="推送到-github"><a href="#推送到-github" class="headerlink" title="推送到 github"></a>推送到 github</h3><p>确保在继续之前您已将 <a href="https://medium.com/hackernoon/a-gentle-introduction-to-git-and-github-the-eli5-way-43f0aa64f2e4">所有代码推送到 github</a> :)</p><h2 id="部署你的-dApp"><a href="#部署你的-dApp" class="headerlink" title="部署你的 dApp"></a>部署你的 dApp</h2><p>我们现在将部署您的 dApp，以便每个人都可以看到您的网站，并且您可以与所有 LearnWeb3 DAO 朋友分享它。</p><ul><li>转到<a href="https://vercel.com/">Vercel</a>并使用您的 GitHub 登录</li><li>然后单击<code>New Project</code>按钮，然后选择您的白名单 dApp 存储库</li><li><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level8/2.png?raw=true"></li><li>在配置您的新项目时，Vercel 将允许您自定义您的<code>Root Directory</code></li><li>单击<code>Edit</code>旁边<code>Root Directory</code>并将其设置为<code>my-app</code></li><li>选择框架为<code>Next.js</code></li><li>点击<code>Deploy</code></li><li>现在，您可以通过转到仪表板、选择您的项目并复制 URL 来查看您部署的网站 - 从那里！</li></ul><p>在 Discord 中分享您的网站 :D</p>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>入门混合主题</title>
    <link href="http://blog.julysong.com/2022/09/01/web3-sophomore-level7/"/>
    <id>http://blog.julysong.com/2022/09/01/web3-sophomore-level7/</id>
    <published>2022-09-01T06:23:48.000Z</published>
    <updated>2025-02-20T06:39:02.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/1d605529-789e-42a9-b193-c07322498498">Sophomore Mixed Topics</a></p><p>翻译: JulySong</p></blockquote><p>有一些主题我们想提供一些信息，但不够详细，不值得拥有自己的水平。这个级别旨在将一堆单独的主题组合在一起，并回顾一些有助于记住的事情。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/1d605529-789e-42a9-b193-c07322498498#providers-and-signers">提供者和签名者(Providers and Signers)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/1d605529-789e-42a9-b193-c07322498498#bignumbers">大数(BigNumbers)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/1d605529-789e-42a9-b193-c07322498498#abi">ABI</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/1d605529-789e-42a9-b193-c07322498498#erc20-approval-flow">ERC20 审批流程(ERC20 Approval Flow)</a></li></ul><h2 id="提供者和签名者-Providers-and-Signers"><a href="#提供者和签名者-Providers-and-Signers" class="headerlink" title="提供者和签名者(Providers and Signers)"></a>提供者和签名者(Providers and Signers)</h2><p>在构建智能合约接口时，您通常会遇到这两个术语 -<code>Provider</code>和<code>Signer</code>. 当您实际开始使用它们时，您将对它们有更好的理解，我们将尝试简要解释它们的含义。</p><p>我们知道，要向区块链读取或写入数据，我们需要通过以太坊节点进行通信。该节点包含区块链状态，允许我们读取数据。它还可以向矿工广播交易，允许我们写入数据。</p><p>请注意，如果您想将数据写入区块链，节点只需要广播交易。因为如果你只是读取已经存在的数据，矿工不需要做任何事情，他们已经完成了他们的工作。</p><p><code>Provider</code>是一个以太坊节点连接，允许您从其状态读取数据。您将使用 <code>Provider</code>来执行诸如调用智能合约中的只读函数、获取账户余额、获取交易详细信息等操作。</p><p><code>Signer</code>是一个以太坊节点连接，允许您将数据写入区块链。您将使用 <code>Signer</code>来执行诸如调用智能合约中的写入函数、在账户之间转移 ETH 等事情。为此，<code>Signer</code>需要访问<code>Private Key</code>可用于代表账户进行交易的。</p><p>此外，一个<code>Signer</code>可以做任何事情<code>Provider</code>。您可以同时使用<code>Signer</code>进行读取和写入，但<code>Provider</code>仅适用于读取数据。</p><p>默认情况下，像 Metamask 这样的钱包会将 <code>Provider</code>注入您的浏览器。因此，dApp 可以使用您的 Metamask<code>Provider</code>从您的钱包连接的区块链网络中读取值。</p><p>但是，有时，您希望用户进行事务，而不仅仅是读取数据。当然，Metamask 不能只与随机网站共享您的私钥——那太疯狂了。为此，Metamask 还允许网站请求<code>Signer</code>. 因此，当 dApp 尝试向区块链发送交易时，会弹出 Metamask 窗口，要求用户确认操作。</p><h2 id="大数-BigNumbers"><a href="#大数-BigNumbers" class="headerlink" title="大数(BigNumbers)"></a>大数(BigNumbers)</h2><p>在学习 Solidity 时，我们一直在阅读和使用<code>uint256</code>很多东西。<code>uint256</code>范围从<code>0</code>到<code>(2^256) - 1</code>。因此，数据类型可以容纳的最大数量<code>uint256</code>是天文数字。</p><p>具体来说，最大值为<code>uint256</code>：</p><p><code>115792089237316195423570985008687907853269984665640564039457584007913129639935</code></p><p>相比之下，一百万是：</p><p><code>1000000</code></p><p>显然，<code>uint256</code>可以容纳非常大的数字。但这提出了一个问题。</p><p>我们通常用 Javascript 为智能合约构建接口。Javascript 的<code>number</code>数据类型的上限要小得多。</p><p>具体来说，Javascript 可以容纳的数值类型的最大值只是：</p><p><code>9007199254740991</code></p><p>那甚至不接近<code>uint256</code>可以容纳的东西！</p><p>因此，假设我们使用 Javascript 调用智能合约上的一个函数，该函数返回一个<code>uint256</code>. 如果该数字大于 Javascript 的最大数值，这绝对是可能的，那么会发生什么？</p><p>好吧，事实证明，Javascript 无法支持这一点。因此，我们必须使用一种称为 <code>BigNumber</code> 的特殊类型。用于与以太坊节点交互的库 - <code>ethers.js</code> 并且 <code>web3.js</code> - 都支持 <code>BigNumber</code>.</p><p><code>BigNumber</code>是一个用 Javascript 编写的自定义类库，它引入了它自己的数学函数函数 - <code>add</code>、<code>sub</code>、<code>mul</code>、<code>div</code>等。<code>BigNumber</code>与 Javascript 本身支持的数字相比，它的数字容量要大得多。</p><p>当我们在以下级别编写代码时，您会遇到通过调用诸如 <code>and</code> 之类的函数来完成数学运算<code>.add()</code>，而不是我们所知道<code>.mul()</code>的典型的<code>+</code>and<code>*</code>运算符 - 这是因为当我们使用 BigNumber 时，我们需要使用它的数学函数。</p><p>至于如果我们尝试使用 Javascript 数字执行此操作会发生什么，我们很容易上溢或下溢。这意味着我们的计算将完全不正确且未定义。所以，请记住这一点。</p><h2 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h2><p>ABI 代表应用程序二进制接口。在使用以太坊时，这是比较难理解的事情之一，但我们会尽力解释它。</p><p>在新生教程中，在教程中你会进一步遇到，你会大量使用<code>ABI</code>。</p><p>当 Solidity 代码被编译时，它被编译成本质上是二进制的字节码。它不包含合约中存在的函数名称、它们包含的参数以及它们返回的值的记录。</p><p>但是，如果您想从 Web 应用程序调用 Solidity 函数，则需要一种在合约中调用正确字节码的方法。为此，您需要一种将人类可读的函数名称和参数转换为字节码并返回的方法。</p><p>ABI 可以帮助我们实现这一目标。当你编译你的 Solidity 代码时，编译器会自动生成一个 ABI。它包含有关合约中存在的功能的规则和元数据，有助于进行正确的数据来回转换。</p><p>所以，当你想调用一个合约时，你需要它的地址（当然），但你也需要提供它的 ABI。像这样的库<code>ethers.js</code>使用 ABI 将人类可读的函数编码和解码为字节码，然后在与以太坊节点通信和调用智能合约中的函数时返回。</p><h2 id="ERC20-审批流程-ERC20-Approval-Flow"><a href="#ERC20-审批流程-ERC20-Approval-Flow" class="headerlink" title="ERC20 审批流程(ERC20 Approval Flow)"></a>ERC20 审批流程(ERC20 Approval Flow)</h2><p>过去，我们了解了<code>payable</code>允许智能合约在调用函数时接受 ETH 付款的函数。如果您想以 ETH 向用户收费以换取某些东西（例如 NFT 销售），这非常有用。</p><p>但是，如果你想使用 ETH 以外的东西进行支付怎么办？如果您想使用自己部署的加密货币进行支付怎么办？</p><p>这里的事情有点棘手。</p><p>由于 ETH 是以太坊的原生货币，而且 ERC20 标准是在以太坊发明之后很久才引入的，所以它们的行为方式并不完全相同。具体来说，接受 ERC20 代币支付并不像在 Solidity 中创建一个<code>payable</code>函数那么简单。</p><p>该<code>payable</code>关键字仅适用于 ETH 支付。如果您想使用自己的 ERC20 加密货币，那么执行此操作的流程会稍微复杂一些。</p><p>首先，让我们稍微考虑一下。</p><ul><li><p>好的，所以你不能像使用 ETH 一样发送 ERC20 代币和函数调用</p></li><li><p>也许智能合约可以以某种方式从函数调用者的帐户中提取代币？</p></li><li><p>但这意味着我可以编写一个智能合约，如果有人用我的合约进行交易，它会窃取每个人的代币</p></li><li><p>因此，我们需要一种更安全的方法来从某人的帐户中提取代币，这就是 <code>Approve and Transfer</code> 流量的来源。</p></li></ul><p>该<code>ERC20</code>标准带有津贴的概念。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level7/1.png?raw=true"></p><p>让我们试着借助一个例子来思考这个问题。</p><hr><ul><li>Alice 想卖掉她的 NFT</li><li>Alice 想用她自己的加密货币 AliceCoin 接受她的 NFT 付款</li><li>Alice 的 NFT 花费 10 AliceCoin</li><li>Bob 拥有 AliceCoin</li><li>Bob 想购买 Alice 的 NFT</li><li>Bob 需要一种方法来调用 Alice 的 NFT 智能合约上的函数，该函数将收取 10 Alicecoin 的付款，并将他的 NFT 发送给他</li><li>由于智能合约不能直接接受 Alicecoin 作为支付，Alice 在她的 NFT 合约中编码了<code>ERC20 Approval and Transfer</code>流程</li></ul><hr><p><code>Alicecoin</code> 是 ERC20 代币。ERC20 内置了一些与 Allowance 概念相关的功能。</p><p><code>approve(address spender, uint256 amount)</code></p><p>这允许用户在<code>approve</code>不同的地址代表他们花费最多<code>amount</code>代币。即此功能提供了<code>spender</code>最多的津贴<code>amount</code></p><p><code>transferFrom(address from, address to, uint256 amount)</code></p><p>允许用户将<code>amount</code>令牌从转移<code>from</code>到<code>to</code>。</p><p>如果调用函数的用户与<code>from</code>地址相同，则从用户余额中删除代币。</p><p>如果用户是<code>from</code>地址以外的其他人，则该<code>from</code>地址必须在过去给予用户使用该<code>approve</code>功能<code>amount</code>使用代币的许可。</p><hr><p>现在继续这个例子：</p><ul><li>Bob 允许 Alice 的 NFT 合约<code>Alicecoin</code>使用该<code>approve</code>功能最多花费 10</li><li>Bob 调用该函数在 Alice 的 NFT 合约上购买她的 NFT</li><li>购买函数内部调用<code>transferFrom</code>并<code>Alicecoin</code>从 Bob 的账户中将 10 <code>Alicecoin</code> 转移到 Alice 的账户中</li><li>由于之前 Bob 允许合约使用最多 10 个 <code>Alicecoin</code>，因此允许此操作</li><li>因此，Alice 收到了她的 10 个 <code>Alicecoin</code>，Bob 收到了他的 NFT</li></ul><hr><p>好的，那么这对我们意味着什么？</p><p>好吧，请注意 Bob 必须如何批准合同，因此合同可以从 Bob 的帐户中提取 Bob 的代币。</p><p>因此，如果在 ETH 中接受付款，Bob 基本上必须进行两次交易来复制一次交易中可以完成的行为。</p><p>交易 1 - 为合约提供津贴 交易 2 - 调用合约函数，该函数在内部使用津贴将 Bob 的代币转移到不同的地址</p><p>因此，如果您正在构建一个 dApp，您需要用户使用 ERC20 代币支付您的智能合约，您还需要让他们同时进行这两项交易。简单地调用你的合约函数，而不首先让你的用户为你的合约提供津贴，将导致函数调用失败。</p><hr><p>在大二课程的最后一级构建 DeFi-Exchange 时，我们将遇到此流程的一个用例。由于交易所涉及能够将一种代币转换为另一种代币，因此您需要在交易所智能合约上调用一个函数，该函数接收一个代币并为您提供另一个代币。</p><p>要使用您的代币进行交换，交换合约需要获得批准才能从您的账户中提取代币。</p><p>因此，如果您想知道为什么在交易所进行交换可以使用两笔交易而不是一笔交易，请记住这一流程。</p><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 什么是提供者(Provider)？</p><p>A: 以太坊节点连接，可帮助您从状态中读取数据</p><p>B: 以太坊节点连接，帮助您写入数据状态</p><p>C: 可读写的以太坊节点连接</p></li><li><p>🤔 什么是签名者(Signer)？</p><p>A: 以太坊节点连接，可帮助您从状态中读取数据</p><p>B: 以太坊节点连接，帮助您写入数据状态</p><p>C: 可读写的以太坊节点连接</p></li><li><p>🤔 我们如何在 Bignumber 中进行乘法运算？</p><p>A: 使用 .mul()</p><p>B: 使用 *</p><p>C: 使用 x</p></li><li><p>🤔 ABI 包含什么？</p><p>A: 它是一个任意数组，它可以包含任何东西</p><p>B: 包含有关合约中存在的功能的规则和元数据</p><p>C: 仅包含合约中关于函数的规则</p><p>D: 仅包含有关合约中存在的功能的元数据</p></li><li><p>🤔 如果 Alice 想要一份合约从她那里拿走一些 ERC20 代币，她会怎么做？</p><p>A: 合约上的调用<code>transferFrom</code>函数</p><p>B: ERC-20 合约上的调用<code>approve</code>函数</p><p>C: ERC-20 合约上的调用<code>pay</code>函数</p><p>D: ERC-20 合约上调用<code>approve</code>函数,然后在合约上调用一些内部使用的函数 transferFrom</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>C</li><li>A</li><li>B</li><li>D</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>高级 Solidity 主题</title>
    <link href="http://blog.julysong.com/2022/08/31/web3-sophomore-level6/"/>
    <id>http://blog.julysong.com/2022/08/31/web3-sophomore-level6/</id>
    <published>2022-08-31T11:36:26.000Z</published>
    <updated>2025-02-20T06:39:02.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855">Advanced Solidity Topics</a></p><p>翻译: JulySong</p></blockquote><p>在新生课程中，我们查看了一些基本的 Solidity 语法。我们涵盖了变量、数据类型、函数、循环、条件流和数组。</p><p>然而，Solidity 还有一些东西，这些东西对于大二及以后的编码任务很重要。在本教程中，我们将介绍一些更重要的 Solidity 主题。</p><h2 id="喜欢视频？"><a href="#喜欢视频？" class="headerlink" title="喜欢视频？"></a>喜欢视频？</h2><p>如果您想从视频中学习，我们的 YouTube 上有本教程的录音。它分为两部分，并且有时间戳。单击下面的屏幕截图观看视频，或继续阅读教程！</p><h3 id="第-1-部分"><a href="#第-1-部分" class="headerlink" title="第 1 部分"></a>第 1 部分</h3><p><a href="https://www.youtube.com/watch?v=Z5P3rKBRmEM">视频</a></p><h3 id="第-2-部分"><a href="#第-2-部分" class="headerlink" title="第 2 部分"></a>第 2 部分</h3><p><a href="https://www.youtube.com/watch?v=ILY3fIbwjk0">视频</a></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#mappings">映射(Mappings)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#enums">枚举(Enums)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#structs">结构(Structs)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#view-and-pure-functions">视图和纯函数(View and Pure Functions)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#function-modifiers">函数修饰符(Function Modifiers)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#events">活动(Events)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#constructors">构造函数(Constructors)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#inheritance">遗产(Inheritance)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#transferring-eth">转移 ETH(Transferring ETH)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#calling-external-contracts">调用外部合约(Calling external contracts)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#import-statements">导入语句(Import statements)</a></li><li><a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/18dad5bd-3a51-4d2e-944e-db37edd74855#solidity-libraries">Solidity 库(Solidity Libraries)</a></li></ul><h2 id="映射-Mappings"><a href="#映射-Mappings" class="headerlink" title="映射(Mappings)"></a>映射(Mappings)</h2><p>Solidity 中的映射就像其他编程语言中的哈希图或字典一样。它们用于将数据存储在键值对中。</p><p>映射是使用语法创建的 <code>mapping (keyType =&gt; valueType)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Mapping &#123;</span><br><span class="line">    // 从地址映射到 uint</span><br><span class="line">    mapping(address =&gt; uint) public myMap;</span><br><span class="line"></span><br><span class="line">    function get(address _addr) public view returns (uint) &#123;</span><br><span class="line">        // 映射总是返回一个值。</span><br><span class="line">        // 如果该值从未设置，它将返回默认值。</span><br><span class="line">        // uint 的默认值为 0</span><br><span class="line">        return myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(address _addr, uint _i) public &#123;</span><br><span class="line">        // 更新这个地址的值</span><br><span class="line">        myMap[_addr] = _i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove(address _addr) public &#123;</span><br><span class="line">        // 将值重置为默认值。</span><br><span class="line">        delete myMap[_addr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以创建嵌套映射，其中<code>key</code>指向第二个嵌套映射。为此，我们将 设置<code>valueType</code>为映射本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">contract NestedMappings &#123;</span><br><span class="line">    // 从地址映射 =&gt; (从 uint 映射到 bool)</span><br><span class="line">    mapping(address =&gt; mapping(uint =&gt; bool)) public nestedMap;</span><br><span class="line"></span><br><span class="line">    function get(address _addr1, uint _i) public view returns (bool) &#123;</span><br><span class="line">        // 你可以从嵌套映射中获取值</span><br><span class="line">        // 即使它没有初始化</span><br><span class="line">        // bool 类型的默认值为 false</span><br><span class="line">        return nestedMap[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function set(</span><br><span class="line">        address _addr1,</span><br><span class="line">        uint _i,</span><br><span class="line">        bool _boo</span><br><span class="line">    ) public &#123;</span><br><span class="line">        nestedMap[_addr1][_i] = _boo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function remove(address _addr1, uint _i) public &#123;</span><br><span class="line">        delete nestedMap[_addr1][_i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举-Enums"><a href="#枚举-Enums" class="headerlink" title="枚举(Enums)"></a>枚举(Enums)</h2><p>这个词<code>Enum</code>代表<code>Enumerable</code>。它们是用户定义的类型，其中包含一组常量（称为成员）的人类可读名称。它们通常用于将变量限制为仅具有几个预定义值之一。由于它们只是人类可读常量的抽象，实际上，它们在内部表示为<code>uint</code>s。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Enum &#123;</span><br><span class="line">    // 代表不同可能运输状态的</span><br><span class="line">    enum Status &#123;</span><br><span class="line">        Pending,</span><br><span class="line">        Shipped,</span><br><span class="line">        Accepted,</span><br><span class="line">        Rejected,</span><br><span class="line">        Canceled</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明一个 Status 类型的变量</span><br><span class="line">    // 这只能包含一个预定义的值</span><br><span class="line">    Status public status;</span><br><span class="line"></span><br><span class="line">    // 因为枚举在内部由uint 表示</span><br><span class="line">    // 此函数将始终返回一个 uint</span><br><span class="line">    // Pending = 0</span><br><span class="line">    // Shipped = 1</span><br><span class="line">    // Accepted = 2</span><br><span class="line">    // Rejected = 3</span><br><span class="line">    // Canceled = 4</span><br><span class="line">    // 不能大于 4被返回</span><br><span class="line">    function get() public view returns (Status) &#123;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为输入传递一个 uint 以更新值</span><br><span class="line">    function set(Status _status) public &#123;</span><br><span class="line">        status = _status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新特定枚举成员的值</span><br><span class="line">    function cancel() public &#123;</span><br><span class="line">        status = Status.Canceled; // 将设置状态 = 4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构-Structs"><a href="#结构-Structs" class="headerlink" title="结构(Structs)"></a>结构(Structs)</h2><p>结构的概念存在于许多高级编程语言中。它们用于定义您自己的数据类型，这些数据类型将相关数据组合在一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract TodoList &#123;</span><br><span class="line">    // 声明一个将两种数据类型组合在一起的</span><br><span class="line">    struct TodoItem &#123;</span><br><span class="line">        string text;</span><br><span class="line">        bool completed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个 TodoItem 结构数组</span><br><span class="line">    TodoItem[] public todos;</span><br><span class="line"></span><br><span class="line">    function createTodo(string memory _text) public &#123;</span><br><span class="line">        // 有多种初始化结构的方法</span><br><span class="line"></span><br><span class="line">        // 方法 1 - 像函数一样调用它</span><br><span class="line">        todos.push(TodoItem(_text, false));</span><br><span class="line"></span><br><span class="line">        // 方法 2 - 显式设置其键</span><br><span class="line">        todos.push(TodoItem(&#123; text: _text, completed: false &#125;));</span><br><span class="line"></span><br><span class="line">        // 方法 3 - 初始化一个空结构体，然后设置单个属性</span><br><span class="line">        TodoItem memory todo;</span><br><span class="line">        todo.text = _text;</span><br><span class="line">        todo.completed = false;</span><br><span class="line">        todos.push(todo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新一个结构体值</span><br><span class="line">    function update(uint _index, string memory _text) public &#123;</span><br><span class="line">        todos[_index].text = _text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新完成</span><br><span class="line">    function toggleCompleted(uint _index) public &#123;</span><br><span class="line">        todos[_index].completed = !todos[_index].completed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图和纯函数-View-and-Pure-Functions"><a href="#视图和纯函数-View-and-Pure-Functions" class="headerlink" title="视图和纯函数(View and Pure Functions)"></a>视图和纯函数(View and Pure Functions)</h2><p>您可能已经注意到，我们一直在编写的一些函数在函数头中指定了<code>view</code>或<code>pure</code>关键字之一。这些是特殊关键字，表示函数的特定行为。</p><p>Getter 函数（返回值的函数）可以声明为<code>view</code>或<code>pure</code>。</p><ul><li><code>View</code>: 不改变任何状态值的函数</li><li><code>Pure</code>: 不改变任何状态值，但也不读取任何状态值的函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract ViewAndPure &#123;</span><br><span class="line">    // 声明一个状态变量</span><br><span class="line">    uint public x = 1;</span><br><span class="line"></span><br><span class="line">    // 承诺不修改状态（但可以读取状态）</span><br><span class="line">    function addToX(uint y) public view returns (uint) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 承诺不修改或读取状态</span><br><span class="line">    function add(uint i, uint j) public pure returns (uint) &#123;</span><br><span class="line">        return i + j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数修饰符-Function-Modifiers"><a href="#函数修饰符-Function-Modifiers" class="headerlink" title="函数修饰符(Function Modifiers)"></a>函数修饰符(Function Modifiers)</h2><p>修饰符是可以在函数调用之前和&#x2F;或之后运行的代码。它们通常用于限制对某些功能的访问、验证输入参数、防止某些类型的攻击等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Modifiers &#123;</span><br><span class="line">    address public owner;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        // 设置合约部署者为合约</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个只允许所有者调用函数的</span><br><span class="line">    modifier onlyOwner() &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;You are not the owner&quot;);</span><br><span class="line"></span><br><span class="line">        // 下划线是修饰符内部使用的特殊字符</span><br><span class="line">        // 它告诉 Solidity 此时执行该修饰符所用的函数</span><br><span class="line">        // 因此，这个修饰符将首先执行上述检查</span><br><span class="line">        // 然后运行其余代码</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建一个函数并对其应用 onlyOwner 修饰符</span><br><span class="line">    function changeOwner(address _newOwner) public onlyOwner &#123;</span><br><span class="line">        // 只有当修饰符通过检查成功时，我们才会到达这一点</span><br><span class="line">        // 所以这个事务的调用者必须是当前的所有者</span><br><span class="line">        owner = _newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="活动-Events"><a href="#活动-Events" class="headerlink" title="活动(Events)"></a>活动(Events)</h2><p>事件允许合约在以太坊区块链上执行日志记录。例如，可以稍后解析给定合约的日志以在前端界面上执行更新。它们通常用于允许前端界面侦听特定事件并更新用户界面，或用作廉价的存储形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Events &#123;</span><br><span class="line">    // 声明一个记录地址和字符串事件的</span><br><span class="line">    event TestCalled(address sender, string message);</span><br><span class="line"></span><br><span class="line">    function test() public &#123;</span><br><span class="line">        // 记录一个事件</span><br><span class="line">        emit TestCalled(msg.sender, &quot;Someone called test()!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数-Constructors"><a href="#构造函数-Constructors" class="headerlink" title="构造函数(Constructors)"></a>构造函数(Constructors)</h2><p><code>constructor</code> 是一个可选函数，在首次部署合约时执行。您还可以将参数传递给构造函数。</p><p>P.S. - 如果你还记得，我们实际上在新生跟踪加密货币和 NFT 教程中使用了构造函数！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract X &#123;</span><br><span class="line">    string public name;</span><br><span class="line"></span><br><span class="line">    // 部署合约时需要提供一个字符串参数</span><br><span class="line">    constructor(string memory _name) &#123;</span><br><span class="line">        // 部署合约时会立即设置</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遗产-Inheritance"><a href="#遗产-Inheritance" class="headerlink" title="遗产(Inheritance)"></a>遗产(Inheritance)</h2><p>继承是一个合同可以继承另一个合同的属性和方法的过程。Solidity 支持多重继承。合约可以使用<code>is</code>关键字继承其他合约。</p><p>注意：我们实际上还在 Freshman Track Cryptocurrency 和 NFT 教程中进行了继承——我们分别从<code>ERC20</code>和<code>ERC721</code>合约继承。</p><p>具有可以被子合约覆盖的函数的父合约必须声明为<code>virtual</code>函数。</p><p>将要覆盖父函数的子合约必须使用<code>override</code>关键字。</p><p>如果父合约以相同的名称共享方法或属性，则继承顺序很重要。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">/* 继承图</span><br><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> /   /</span><br><span class="line">D   E</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    // 声明一个可以被子函数覆盖的虚函数 foo()</span><br><span class="line">    function foo() public pure virtual returns (string memory) &#123;</span><br><span class="line">        return &quot;A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B is A &#123;</span><br><span class="line">    // 覆盖 A.foo();</span><br><span class="line">    // 但也允许这个函数被更多的子函数覆盖</span><br><span class="line">    // 所以我们指定了两个关键字 - virtual 和 override</span><br><span class="line">    function foo() public pure virtual override returns (string memory) &#123;</span><br><span class="line">        return &quot;B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C is A &#123;</span><br><span class="line">    // 类似于上面的合约 B</span><br><span class="line">    function foo() public pure virtual override returns (string memory) &#123;</span><br><span class="line">        return &quot;C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 从多个合约继承时，如果一个函数被多次定义，则使用最右边的父合约的函数。</span><br><span class="line">contract D is B, C &#123;</span><br><span class="line">    // D.foo() 返回 &quot;C&quot;</span><br><span class="line">    // 因为 C 是函数 foo() 的最右边父级；</span><br><span class="line">    // override (B,C) 表示我们要覆盖两个父级中存在的方法</span><br><span class="line">    function foo() public pure override (B, C) returns (string memory) &#123;</span><br><span class="line">        // super 是一个特殊的关键字，用于调用functions</span><br><span class="line">        // 在父合约中</span><br><span class="line">        return super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract E is C, B &#123;</span><br><span class="line">    // E.foo() 返回 &quot;B&quot;</span><br><span class="line">    // 因为 B 是函数 foo() 的最右边父级；</span><br><span class="line">    function foo() public pure override (C, B) returns (string memory) &#123;</span><br><span class="line">        return super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转移-ETH-Transferring-ETH"><a href="#转移-ETH-Transferring-ETH" class="headerlink" title="转移 ETH(Transferring ETH)"></a>转移 ETH(Transferring ETH)</h2><p>有三种方法可以将 ETH 从合约转移到其他地址。但是，其中两种方法在最新版本中不再是 Solidity 推荐的方法，因此我们将跳过它们。</p><p>目前，从合约中转移 ETH 的推荐方式是使用该<code>call</code>功能。该<code>call</code>函数返回一个<code>bool</code>指示传输成功或失败的信息。</p><h3 id="如何在普通的以太坊账户地址接收以太币"><a href="#如何在普通的以太坊账户地址接收以太币" class="headerlink" title="如何在普通的以太坊账户地址接收以太币"></a>如何在普通的以太坊账户地址接收以太币</h3><p>如果将 ETH 转移到普通账户（如 Metamask 地址），您无需做任何特殊的事情，因为所有此类账户都可以自动接受 ETH 转移。</p><h3 id="如何在合约中接收-ETH"><a href="#如何在合约中接收-ETH" class="headerlink" title="如何在合约中接收 ETH"></a>如何在合约中接收 ETH</h3><p>但是，如果您正在编写一份合约，希望能够直接接收 ETH 转账，您必须至少具有以下功能之一</p><ul><li><code>receive() external payable</code></li><li><code>fallback() external payable</code></li></ul><p>如果<code>msg.data</code>是空值则调用<code>receive()</code>，否则使用<code>fallback()</code>。</p><blockquote><p><code>msg.data</code>是一种指定任意数据和事务的方法。您通常不会手动使用它。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract ReceiveEther &#123;</span><br><span class="line">    /*</span><br><span class="line">    调用哪个函数，fallback() 还是 receive()？</span><br><span class="line"></span><br><span class="line">            发送以太币</span><br><span class="line">               |</span><br><span class="line">         msg.data 为空？</span><br><span class="line">              / \</span><br><span class="line">            yes  no</span><br><span class="line">            /     \</span><br><span class="line">receive() 存在吗？  fallback()</span><br><span class="line">         /   \</span><br><span class="line">        是    否</span><br><span class="line">        /      \</span><br><span class="line">    receive()   fallback()</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    // 接收以太币的函数。msg.data 必须为空</span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    // 当 msg.data 不为空时调用 fallback 函数</span><br><span class="line">    fallback() external payable &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SendEther &#123;</span><br><span class="line">    function sendEth(address payable _to) public payable &#123;</span><br><span class="line">        // 只需将在此应付函数中收到的 ETH 转发到给定地址</span><br><span class="line">        uint amountToSend = msg.value;</span><br><span class="line">        // call 返回一个 bool 值，指定成功或失败</span><br><span class="line">        (bool success, bytes memory data) = _to.call&#123;value: msg.value&#125;(&quot;&quot;);</span><br><span class="line">        require(success == true, &quot;Failed to send ETH&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用外部合约-Calling-External-Contracts"><a href="#调用外部合约-Calling-External-Contracts" class="headerlink" title="调用外部合约(Calling External Contracts)"></a>调用外部合约(Calling External Contracts)</h2><p>合约可以通过调用其他合约实例上的函数来调用其他合约，例如<code>A.foo(x, y, z)</code>. 为此，您必须有一个接口<code>A</code>来告诉您的合约存在哪些功能。Solidity 中的接口行为类似于头文件，并且与我们在从前端调用合约时使用的 ABI 具有相似的用途。这允许合约知道如何编码和解码函数参数并返回值以调用外部合约。</p><p>注意：您使用的接口不需要很广泛。即它们不一定需要包含外部合同中存在的所有功能 - 只需要您可能在某个时候调用的那些功能。</p><p>假设有一个外部<code>ERC20</code>合约，我们有兴趣调用该<code>balanceOf</code>函数来检查我们合约中给定地址的余额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">interface MinimalERC20 &#123;</span><br><span class="line">    // 只需在接口包含我们感兴趣的函数</span><br><span class="line">    function balanceOf(address account) external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MyContract &#123;</span><br><span class="line">    MinimalERC20 externalContract;</span><br><span class="line"></span><br><span class="line">    constructor(address _externalContract) &#123;</span><br><span class="line">        // 初始化一个 MinimalERC20 合约实例</span><br><span class="line">        externalContract = MinimalERC20(_externalContract);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function mustHaveSomeBalance() public &#123;</span><br><span class="line">        // 要求该交易的调用者在外部 ERC20 合约中的代币余额为非零</span><br><span class="line">        uint balance = externalContract.balanceOf(msg.sender);</span><br><span class="line">        require(balance &gt; 0, &quot;You don&#x27;t own any tokens of external contract&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Import-声明-Import-Statements"><a href="#Import-声明-Import-Statements" class="headerlink" title="Import 声明(Import Statements)"></a>Import 声明(Import Statements)</h2><p>为了保持代码的可读性，您可以将 Solidity 代码拆分为多个文件。Solidity 允许导入本地和外部文件。</p><h3 id="本地-Import"><a href="#本地-Import" class="headerlink" title="本地 Import"></a>本地 Import</h3><p>假设我们有一个这样的文件夹结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── Import.sol</span><br><span class="line">└── Foo.sol</span><br></pre></td></tr></table></figure><p><code>Foo.sol</code> 在哪里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Foo &#123;</span><br><span class="line">    string public name = &quot;Foo&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以像这样导入<code>Foo</code>和使用它<code>Import.sol</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">// 从当前目录导入 Foo.sol</span><br><span class="line">import &quot;./Foo.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Import &#123;</span><br><span class="line">    // 初始化 Foo.sol</span><br><span class="line">    Foo public foo = new Foo();</span><br><span class="line"></span><br><span class="line">    // 通过获取 Foo.sol 的名称来测试它。</span><br><span class="line">    function getFooName() public view returns (string memory) &#123;</span><br><span class="line">        return foo.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们使用 Hardhat 时，我们也可以通过 将合约安装为节点模块<code>npm</code>，然后从<code>node_modules</code>文件夹中导入合约。这些也算作本地导入，因为从技术上讲，当您安装软件包时，您正在将合同下载到本地计算机。</p><h3 id="外部-Import"><a href="#外部-Import" class="headerlink" title="外部 Import"></a>外部 Import</h3><p>您也可以通过简单地复制 URL 从 Github 导入。我们在新生课程的加密货币和 NFT 教程中做到了这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/owner/repo/blob/branch/path/to/Contract.sol</span><br><span class="line">import &quot;https://github.com/owner/repo/blob/branch/path/to/Contract.sol&quot;;</span><br><span class="line"></span><br><span class="line">// 示例从 openzeppelin-contract repo 导入 ERC20.sol</span><br><span class="line">// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol</span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;</span><br></pre></td></tr></table></figure><h2 id="Solidity-库"><a href="#Solidity-库" class="headerlink" title="Solidity 库"></a>Solidity 库</h2><p>库类似于 Solidity 中的合约，但有一些限制。库不能包含任何状态变量，也不能转移 ETH。</p><p>通常，库用于向您的合约添加辅助函数。Solidity 世界中一个非常常用的库是<code>SafeMath</code>- 它确保数学运算不会导致整数下溢或溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">library SafeMath &#123;</span><br><span class="line">    function add(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class="line">        uint z = x + y;</span><br><span class="line">        // 如果 z 溢出，抛出错误</span><br><span class="line">        require(z &gt;= x, &quot;uint overflow&quot;);</span><br><span class="line">        return z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TestSafeMath &#123;</span><br><span class="line">    function testAdd(uint x, uint y) public pure returns (uint) &#123;</span><br><span class="line">        return SafeMath.add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 映射(Mappings)的行为类似于哪种数据结构？</p><p>A: Arrays</p><p>B: Trees</p><p>C: Graphs</p><p>D: Hashmaps</p></li><li><p>🤔 枚举(enums)有什么用？</p><p>A: 将变量限制为仅具有几个预定义值之一。</p><p>B: 将函数限制为仅具有几个预定义值之一</p><p>C: 将接口限制为仅具有几个预定义值之一</p></li><li><p>🤔 结构(structs)是用来做什么的？</p><p>A: 创建自定义数据类型</p><p>B: 限制变量只有几个预定义的值</p><p>C: 存储键值对</p><p>D: 登录到区块链</p></li><li><p>🤔 纯函数(Pure functions)用于将数据写入区块链</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 视图函数(View functions)不会改变任何状态值</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 修饰符(modifiers)不用于什么？</p><p>A: 限制对某些功能的访问</p><p>B: 验证输入参数</p><p>C: 功能替换</p><p>D: 防止某些类型的攻击</p></li><li><p>🤔 事件(events)有什么用？</p><p>A: 登录到区块链</p><p>B: 创建自定义数据类型</p><p>C: 创建在特定时间间隔后运行的函数</p></li><li><p>🤔 构造函数(constructor)是可选的吗？</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 contract B is A { }</p><p>A: A 继承了 B</p><p>B: B 继承 A</p><p>C: A 和 B 是同一份合约</p></li><li><p>🤔 你必须有一个智能合约才能将 ETH 发送到另一个 ETH 地址</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 如果你想让你的合约直接接收 ETH 转账，你必须使用“receive() external pay”或“fallback() external pay”</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 库可以包含状态变量</p><p>A: 是的</p><p>B: 错误</p></li></ol><blockquote><p>参考答案:</p><ol><li>D</li><li>A</li><li>A</li><li>B</li><li>A</li><li>C</li><li>A</li><li>A</li><li>B</li><li>B</li><li>A</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>以太坊虚拟机 (EVM)</title>
    <link href="http://blog.julysong.com/2022/08/29/web3-sophomore-level5/"/>
    <id>http://blog.julysong.com/2022/08/29/web3-sophomore-level5/</id>
    <published>2022-08-29T10:08:40.000Z</published>
    <updated>2025-02-20T06:39:02.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/519a4df5-dc55-4237-bd44-de846ef50e8d">Ethereum Virtual Machine (EVM)</a></p><p>翻译: JulySong</p></blockquote><p>以太坊网络的存在仅是为了保持以太坊区块链状态机的单一、连续、不间断和不可变的操作。它是所有以太坊账户、智能合约和数据所在的环境。在任何给定的区块中，以太坊都有一个也是唯一一个全球公认的“状态”。以太坊虚拟机 (EVM) 定义了从块到块计算新的有效状态的规则。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><p>理解 EVM 需要对 <a href="https://en.wikipedia.org/wiki/Byte">字节</a>, <a href="https://en.wikipedia.org/wiki/Computer_memory">内存</a>, 和 <a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">堆栈</a> 有一些基本的了解。</p><p>熟悉一些密码学（如 <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">散列函数</a>）也可能会有所帮助。</p><h2 id="以太坊作为状态机"><a href="#以太坊作为状态机" class="headerlink" title="以太坊作为状态机"></a>以太坊作为状态机</h2><p>像比特币这样的区块链通常被描述为“分布式账本”，它使用密码学的基本工具来实现去中心化货币的存在。</p><p>加密货币的行为可以像“正常”货币一样，因为规则规定了人们可以做什么和不可以做什么来修改这个分类帐。例如，一个比特币地址不能花费比它之前收到的更多的比特币。这些规则支持在比特币以及类似的其他区块链上发生的所有交易。</p><p>虽然以太坊也有其原生加密货币以太币，但它还支持我们已经看到的更强大的功能——智能合约。对于这个更复杂的功能，我们需要一个比“分布式账本”更强大的类比。</p><p>以太坊可以描述为分布式<a href="https://en.wikipedia.org/wiki/Finite-state_machine">状态机</a>，而不是分布式账本。状态机本质上是可以响应某些输入而从一种状态变为另一种状态的任何机器。</p><p>简单的状态机是一种投币式<a href="https://i.imgur.com/Uh7m6jN.png">旋转闸门</a>，常见于地铁或火车站，用于防止人们进入，除非他们使用硬币支付或持有车票。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level5/1.png?raw=true"></p><p>旋转门的初始状态是锁定的。在锁定状态下，如果你继续推动它，它会保持锁定状态。如果您插入硬币，它会进入解锁状态。如果您继续插入硬币，它会保持解锁状态。一旦您进入解锁状态（有人通过），它就会再次锁定。</p><p>对于以太坊来说，状态要复杂得多。它使用包含区块链所有状态的大型数据结构来描述。状态如何从一个块到另一个块的变化的具体规则由 EVM 定义。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level5/2.png?raw=true"></p><h2 id="以太坊状态转换"><a href="#以太坊状态转换" class="headerlink" title="以太坊状态转换"></a>以太坊状态转换</h2><p>在高层次上，EVM 的行为类似于数学状态转换函数。给定当前状态和一组新的有效交易，它会产生一个新状态。输出是确定性的，这意味着对于相同的输入，它总是会产生相同的输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y(S, T) = S&#x27;</span><br></pre></td></tr></table></figure><p>给定旧的有效状态<code>S</code>和一组新的有效交易<code>T</code>，状态转换函数<code>Y</code>产生新的有效状态<code>S&#39;</code>。</p><p>以太坊中的状态存储为一个非常大的数据结构，称为<a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/">Merkle Patricia Trie(帕特里夏默克尔树)</a>。您不需要确切了解它的结构，但如果您愿意，可以阅读给定的链接。</p><h2 id="EVM-层"><a href="#EVM-层" class="headerlink" title="EVM 层"></a>EVM 层</h2><p>EVM 作为以太坊软件堆栈中的一个层存在。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level5/3.png?raw=true"></p><p>以太坊节点包含 EVM 的实现，然后 EVM 可以在其上执行 EVM 代码。EVM 代码是编译后的可以执行的智能合约字节码。</p><h2 id="EVM-代码生成"><a href="#EVM-代码生成" class="headerlink" title="EVM 代码生成"></a>EVM 代码生成</h2><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level5/4.png?raw=true"><br><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level5/5.png?raw=true"></p><h2 id="EVM-指令（操作码）"><a href="#EVM-指令（操作码）" class="headerlink" title="EVM 指令（操作码）"></a>EVM 指令（操作码）</h2><p>EVM 本身就像一个<a href="https://en.wikipedia.org/wiki/Stack_machine">堆栈机器</a>，堆栈上的最大深度为 1024 个项目。堆栈中的每一项都是一个 256 位（32 字节）的字。</p><p>在执行期间，EVM 维护一个临时内存，作为一个 32 字节寻址的字节数组，它不会在事务之间持续存在。执行新事务时清除瞬态内存。</p><p>然而，智能合约确实在区块链中维护自己的状态。该状态也被建模为 Merkle Patricia Trie。这通常被称为事务执行期间的 EVM 存储。</p><p>EVM 具有允许其执行 EVM 操作码的逻辑，这些操作码在堆栈上执行标准操作，例如 XOR、ADD、AND、SUB、MUL 等。EVM 还实现了许多区块链特定的堆栈操作，例如 BALANCE 和 BLOCKHASH .</p><p>当智能合约被编译成字节码（以十六进制表示）时，它会编译成 EVM 操作码。这些操作码是在 EVM 上执行的。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level5/6.png?raw=true"></p><h2 id="EVM-实现"><a href="#EVM-实现" class="headerlink" title="EVM 实现"></a>EVM 实现</h2><p>EVM 的所有实现都必须遵守<a href="https://ethereum.github.io/yellowpaper/paper.pdf">以太坊黄皮书</a>中描述的规范。在以太坊的历史上，EVM 经历了多次修订，现在存在多种编程语言的 EVM 实现。</p><p>所有以太坊客户端都包含一个 EVM 实现。除此之外，还有多个独立的实现。</p><h2 id="以太坊客户端（带有-EVM）"><a href="#以太坊客户端（带有-EVM）" class="headerlink" title="以太坊客户端（带有 EVM）"></a>以太坊客户端（带有 EVM）</h2><ul><li><a href="https://geth.ethereum.org/">Geth</a> | 编程语言 &#x3D; Go</li><li><a href="https://github.com/openethereum/openethereum">OpenEthereum</a> | 编程语言 &#x3D; Rust</li><li><a href="https://nethermind.io/">Nethermind</a> | 编程语言 &#x3D; C# (.NET)</li><li><a href="https://consensys.net/quorum/developers/">Besu</a> | 编程语言 &#x3D; Java</li><li><a href="https://github.com/ledgerwatch/erigon">Erigon</a> | 编程语言 &#x3D; Go</li></ul><h2 id="独立-EVM-实现"><a href="#独立-EVM-实现" class="headerlink" title="独立 EVM 实现"></a>独立 EVM 实现</h2><ul><li><a href="https://github.com/ethereum/py-evm">Py-EVM</a> | 编程语言 &#x3D; Python</li><li><a href="https://github.com/ethereum/evmone">evmone</a> | 编程语言 &#x3D; C++</li><li><a href="https://github.com/ethereumjs/ethereumjs-monorepo">ethereumjs-evm</a> | 编程语言 &#x3D; Javascript</li><li><a href="https://github.com/microsoft/eevm">Enclave EVM</a> | 编程语言 &#x3D; C++</li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>以下是推荐的但可选的阅读&#x2F;查看内容，以了解有关 EVM 的更多信息。</p><ul><li><a href="https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf">以太坊 EVM：图解</a></li><li><a href="https://www.ethervm.io/">EVM 操作码</a></li><li><a href="https://ethereum.github.io/yellowpaper/paper.pdf">以太坊黄皮书</a></li><li><a href="https://www.youtube.com/watch?v=RxL_1AfV7N4">了解 EVM</a></li><li><a href="https://www.youtube.com/watch?v=OxofT39TJgg">Merkle Patricia Trie(帕特里夏默克尔树)</a></li></ul><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 以太坊虚拟机是伦敦的一台可以远程访问的计算机</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 以太坊是一个分布式状态机</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 用于存储以太坊状态的数据结构叫什么？</p><p>A: Merkle Patricia Trie(帕特里夏默克尔树)</p><p>B: Graphs</p><p>C: Heaps</p><p>D: Arrays</p></li><li><p>🤔 EVM 定义了从块到块的状态计算规则。</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 区块链从根本上适用于密码学的概念</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 以下哪一项不是 EVM 的基本构建块</p><p>A: Stack</p><p>B: Memory</p><p>C: Program Counter</p><p>D: Array</p></li><li><p>🤔 EVM 支持无限递归</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 EVM 有 OPCODES，代表虚拟机的硬件级指令</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 只有一个以太坊客户端实现可用；并且在 Solidity 中</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 以太坊上的智能合约只能用 Solidity 编写</p><p>A: 是的</p><p>B: 错误</p></li></ol><blockquote><p>参考答案:</p><ol><li>B</li><li>A</li><li>A</li><li>A</li><li>A</li><li>D</li><li>B</li><li>A</li><li>B</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>什么是工作证明？</title>
    <link href="http://blog.julysong.com/2022/08/29/web3-sophomore-level4/"/>
    <id>http://blog.julysong.com/2022/08/29/web3-sophomore-level4/</id>
    <published>2022-08-29T06:41:49.000Z</published>
    <updated>2025-02-20T06:39:02.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/9dce5d05-acf6-4aa6-8a23-91938c4c4537">What is Proof of Work?</a></p><p>翻译: JulySong</p></blockquote><p>与比特币一样，以太坊目前使用一种称为工作证明 (PoW) 的共识协议。这允许以太坊网络上的所有节点就区块链的当前状态达成一致，并保护网络免受各种攻击。</p><blockquote><p>2022 年晚些时候，工作量证明将被逐步淘汰，取而代之的是以太坊 2.0 的权益证明。我们将在后面的文章中讨论这个问题，一旦发生，就会弃用工作证明教程。</p></blockquote><h2 id="什么是共识？"><a href="#什么是共识？" class="headerlink" title="什么是共识？"></a>什么是共识？</h2><p>Merriam-Webster 对“共识”一词的定义如下。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level4/1.png?raw=true"></p><h2 id="什么是共识协议？"><a href="#什么是共识协议？" class="headerlink" title="什么是共识协议？"></a>什么是共识协议？</h2><p>对于像以太坊这样的区块链，本质上是分布式去中心化数据库，网络节点需要就网络的当前状态达成一致。</p><p>共识协议帮助我们就给定点的网络状态达成一致或共识。</p><p>尽管共识协议与构建 dApp 没有直接关系，但理解它们将帮助您理解许多其他概念并构建您的基础。</p><p>共识协议主要是有助于防止某些类型的攻击的经济系统。从理论上讲，攻击者可以通过控制 51% 的网络来破坏共识。共识协议旨在使这种“51% 攻击”在经济上不可行。不同的机制被设计来以不同的方式解决这个问题。</p><h2 id="什么是工作证明？"><a href="#什么是工作证明？" class="headerlink" title="什么是工作证明？"></a>什么是工作证明？</h2><p>工作量证明是一种共识协议，著名的比特币和以太坊使用。</p><h2 id="块生产"><a href="#块生产" class="headerlink" title="块生产"></a>块生产</h2><p>在工作量证明下，矿工负责生产新区块。网络中的矿工相互竞争，以创建充满已处理交易的新区块。然后，获胜者与网络的其他成员共享该区块，并通过他们的辛勤工作获得新铸造的 ETH。</p><p>谁能以最快的速度解决计算困难的数学难题，谁就赢得了这场比赛。这个问题在计算上很难解决，但很容易验证。这个问题的解决方案是我们在<code>什么是采矿?</code>教程。</p><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>网络之所以安全，是因为要获得对网络 51% 的控制权，您将需要 51% 的网络计算能力。然而，由于工作量证明通过挖矿奖励激励矿工，许多不同的矿工群体都对运行挖矿节点感兴趣。因此，在网络上获得 51% 的所有计算能力需要对设备和电能进行巨额投资——这意味着您最终可能会花得比赚的多。</p><h2 id="西比尔抵抗-Sybil-Resistance"><a href="#西比尔抵抗-Sybil-Resistance" class="headerlink" title="西比尔抵抗(Sybil Resistance)"></a>西比尔抵抗(Sybil Resistance)</h2><p>从技术上讲，工作量证明本身并不是一个共识协议——尽管为了简单起见，它通常被称为共识协议。它们实际上是 Sybil 抵抗机制和区块生产者选择器——一种决定谁将成为最新区块生产者的方法。</p><p>Sybil Resistance 衡量协议如何应对 Sybil 攻击。</p><p>当一个用户或组伪装成许多不同的用户时，Sybil 攻击就会出现问题。防止此类攻击的安全性对于分散式区块链至关重要，它允许矿工根据他们投入的资源获得奖励，而不仅仅是随机选择。</p><p>假设，如果我们只是通过随机选择而不是工作证明来选择一个块的生产者，那么可以很容易地执行 Sybil 攻击。</p><p>假设网络上有 2 个矿工。爱丽丝和鲍勃。通过随机选择，他们应该分别获得大约一半的挖矿奖励。现在，查理出现了，但假装是 2 个不同的用户——查理和达西。现在通过随机选择，查理最终将获得 1&#x2F;2 的挖矿奖励，因为他假装是 2 个不同的用户，而爱丽丝和鲍勃各只获得 1&#x2F;4，而不是他们应该得到的 1&#x2F;3。</p><p>工作量证明通过让矿工提供大量计算能力作为抵押品来防止 Sybil 攻击，从而让他们消耗大量电能。这是通过解决计算难题来完成的，以证明矿工正在“投入工作”。这对 Sybil 攻击起到了经济威慑作用。</p><p>由于奖励会分配给成功的矿工，而矿工的成功与他们在网络上的计算能力份额大致成正比，所以无论你假装是 1 个用户还是 2 个或 100 个用户都不再重要。你会得到相同的随着您的计算能力保持不变，您将获得多少挖矿奖励。</p><h2 id="链选择规则"><a href="#链选择规则" class="headerlink" title="链选择规则"></a>链选择规则</h2><p>偶尔，两个矿工会大致同时产生有效区块。这可能导致网络中的不同节点在其区块链中包含不同的块。技术术语是分叉。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level4/2.png?raw=true"></p><p>然而，为了让区块链以稳定的方式运行，需要选择一条连续的链作为“正确的链”，以防止状态分裂。</p><p>比特币和以太坊使用“最长链”规则来做到这一点。哪条链被更多的节点接受并继续增长更长的时间被选为“正确的链”，并摆脱分叉的链。</p><p>工作量证明和最长链规则的结合被称为“中本聪共识”——以比特币的发明者中本聪命名。</p><p>有时，这意味着作为临时分叉的一部分被挖掘的交易可能会在分叉被摆脱以支持不同的更长链时回滚。这就引入了终结性的概念。</p><blockquote><p>形成分叉链并最终被删除的块称为叔块。矿工显然投入了工作来产生那个叔块，并且很可能由于网络延迟而失去了采矿奖励。因此，以太坊网络仍然以 1.75 ETH 的辛勤工作奖励区块矿工叔叔。</p></blockquote><h2 id="最终性"><a href="#最终性" class="headerlink" title="最终性"></a>最终性</h2><p>当交易是无法更改的块的一部分时，交易在以太坊上具有“最终性”。</p><p>由于矿工以去中心化的方式工作，因此可以同时开采两个有效区块。这会创建一个临时分叉。最终，在挖掘和添加后续块后，其中一条链将成为接受链，使其更长。</p><p>但更复杂的是，临时分叉上被拒绝的交易可能已包含在接受链中。这意味着它可能会被逆转。所以最终性是指在考虑交易不可逆之前应该等待的时间。对于以太坊，建议的时间是 6 个区块或 1 分钟多一点。在六个区块之后，您可以相对自信地说交易成功（超过 99.999% 的机会现在不会恢复）。您可以等待更长的时间以获得更大的保证。</p><h2 id="工作证明中的“工作”"><a href="#工作证明中的“工作”" class="headerlink" title="工作证明中的“工作”"></a>工作证明中的“工作”</h2><p>我们一直在谈论一个计算困难的数学问题，矿工需要解决这个问题才能提供合法性证书。但这实际上意味着什么？</p><p>本质上，我们想证明矿工花费了能量和计算能力来计算区块。而且，他们做得比其他人都快。如果我们能证明这一点，这意味着矿工基本上花费了金钱和时间（以能源和计算的形式），因此他们有机会提出一个新的区块。</p><p>生产有效区块符合矿工的最大利益，因为如果他们被发现撒谎（这很容易，因为证书的验证很容易）——他们只是白白浪费了所有的精力和计算，因此浪费了他们的金钱和时间。因此，解决数学问题意味着矿工真的非常想提出新的区块，并且愿意花费精力和计算来获得奖励。</p><p>以太坊工作量证明协议 Ethash 要求矿工进行激烈的试错竞赛。过程如下：</p><ul><li>矿工选择一组交易包含在一个潜在的区块中</li><li>根据他们创建的区块，网络有规则从区块链网络的当前状态中选择一块数据（大约 1GB 大小）。这些规则并不是特别相关，但您可以在 Ethash 文档中阅读更多关于它们的信息。</li><li>他们将数据集通过散列函数来计算一个<code>target</code>值。这<code>target</code>是一个数字，与挖矿难度成反比。挖矿难度越高，<code>target</code>越低，反之亦然。</li><li>然后，矿工使用蛮力尝试找到另一个名为<code>nonce</code>.</li><li>通过散列函数将数据集、目标、<code>nonce</code> 和几个其他值的组合放在一起应该会产生一个低于<code>target</code>.</li><li><code>HashFunction(dataset, target, nonce, ...) = a number</code></li><li>挖矿难度越高，<code>target</code>越低，因此越难找到满足该条件的 <code>nonce</code>。</li><li>矿工一直使用试错法来为满足条件的<code>nonce</code>找到一个有效值。没有公式可以计算<code>nonce</code>。</li></ul><blockquote><p>根据网络上有多少矿工，挖矿难度变得越来越小，以确保大约每 15 秒可以可靠地生成一个块。如果它变得太容易并且有很多矿工，那么出块的速度将远远超过 15 秒。同样，如果它变得太难并且没有很多矿工，那么区块将需要很长时间才能产生。难度由网络自动计算。</p></blockquote><p>除了蛮力之外没有其他方法可以解决这个问题，因为目前不存在反转哈希函数的方法。因此，要知道某个<code>nonce</code>, 当附加到数据集时是否会产生特定的哈希，唯一可能的方法是尝试随机值<code>nonce</code>并检查。</p><p>花点时间彻底阅读本节，这就是工作量证明的全部内容。这可能看起来很虎头蛇尾，但想想我们开始想要证明的东西。我们想证明矿工们辛勤工作来生产这个区块，这对他们来说不是小菜一碟。由于他们努力工作，因此不撒谎符合他们的最大利益。这种计算难题正是这样做的，因为找到一个有效<code>nonce</code>的是一个计算上的困难问题——但验证它很容易，所以其他节点可以很容易地验证矿工确实找到了一个有效的<code>nonce</code>，这意味着他们确实把工作。</p><h2 id="比特币实际上是如何运作的？"><a href="#比特币实际上是如何运作的？" class="headerlink" title="比特币实际上是如何运作的？"></a>比特币实际上是如何运作的？</h2><p>我向所有对区块链的工作原理以及如何验证和生成区块有点好奇的人推荐这个视频。</p><p>观看以下视频，直观地了解我们刚刚读到的有关工作量证明的所有内容。</p><p><a href="https://www.youtube.com/watch?v=bBC-nXj3Ng4">视频</a></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>以下是推荐的但可选的阅读&#x2F;查看，以了解有关工作证明的更多信息。</p><ul><li><a href="https://andersbrownworth.com/blockchain">Anderson Brownworth 区块链挖矿演示</a></li><li><a href="https://www.youtube.com/watch?v=3EUAcxhuoU4">什么是工作证明？币安学院</a></li><li><a href="https://www.youtube.com/watch?v=9V1bipPkCTU">可汗学院对工作量证明的技术解释</a></li><li><a href="https://en.bitcoin.it/wiki/Majority_attack">51% 攻击</a></li><li><a href="https://blog.ethereum.org/2016/05/09/on-settlement-finality/">交易终结</a></li><li><a href="https://eth.wiki/en/concepts/ethash/ethash">Ethash</a></li></ul><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 关于工作量证明，以下哪项是错误的？</p><p>A: 矿工有责任确保没有新用户尝试成为矿工</p><p>B: 矿工负责生产新区块</p><p>C: 矿工有责任确保网络不被篡改</p></li><li><p>🤔 共识协议是不可能被破解&#x2F;篡改的。</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 当一个用户试图伪装成许多不同的用户时，它叫什么？</p><p>A: 女巫攻击(Sybil Attack)</p><p>B: 丹佛伪装(Denver Pretention)</p><p>C: 查理攻击(Charlie Attack)</p></li><li><p>🤔 由于像以太坊这样的区块链本质上是分布式数据库，因此需要就当前状态达成共识。</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 什么是叔块(uncle blocks)？</p><p>A: 子块之后开采的块</p><p>B: 最终被删除的块</p><p>C: 分叉后包含的块</p></li><li><p>🤔 在以太坊上推荐的时间是什么时候，我们几乎可以保证一个区块不会被删除？</p><p>A: 大约 15 秒</p><p>B: 约 1 分钟</p><p>C: 约 2 分钟</p></li><li><p>🤔 当交易是无法更改的区块的一部分时，它在以太坊上具有“最终性”。</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 矿工使用什么技术来解决数学问题以向网络证明他们的工作？</p><p>A: 蛮力(Brute force)</p><p>B: 穿透攻击(Penetration Attack)</p><p>C: 女巫攻击(Sybil Attack)</p></li><li><p>🤔 即使在分叉之后，以太坊使用什么规则来强制执行只有一种链状态？</p><p>A: 女巫链(Sybil Chain)</p><p>B: 最长链(Longest Chain)</p><p>C: 丹佛链(Denver Chain)</p></li><li><p>🤔 当两个不同的块并行产生和包含时，它叫什么？</p><p>A: 终局性(Finality)</p><p>B: 叉子(Fork)</p><p>C: 工作证明(PoW)</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>B</li><li>A</li><li>A</li><li>B</li><li>B</li><li>A</li><li>A</li><li>B</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>什么是采矿?</title>
    <link href="http://blog.julysong.com/2022/08/27/web3-sophomore-level3/"/>
    <id>http://blog.julysong.com/2022/08/27/web3-sophomore-level3/</id>
    <published>2022-08-27T01:50:02.000Z</published>
    <updated>2025-02-20T06:39:02.269Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/872a5d9b-7f4a-4f60-a7d2-9682067b117d">What is Mining?</a></p><p>翻译: JulySong</p></blockquote><p>挖矿是帮助创建新交易块以添加到以太坊区块链网络的过程。它还有助于保护网络免受攻击。</p><p>就像比特币一样，以太坊目前使用工作量证明（PoW）共识机制，该机制严重依赖于挖矿。以太坊矿工利用他们的时间和计算能力来处理新的传入交易并产生新的区块。</p><blockquote><p>以太坊 2.0（计划于 2022 年中后期）将用权益证明(Pos)取代工作量证明(PoW)，这将显着改变新区块的生产方式。稍后我们将讨论 Eth2。</p></blockquote><h2 id="矿工为什么存在？"><a href="#矿工为什么存在？" class="headerlink" title="矿工为什么存在？"></a>矿工为什么存在？</h2><p>大多数人认为挖矿只是添加新交易和创造新硬币的一种方式。但是，我们在上面提到过，挖矿也有助于保持网络安全。这是为什么？</p><p>在像以太坊这样的去中心化系统中，我们需要确保世界上的每个人都同意交易的顺序。</p><p>例如，如果 Alice 向 Bob 发送了 1 ETH，他又发送给 Charlie，则交易的顺序需要如下</p><p>Alice –&gt; Bob 1 ETH</p><p>Bob –&gt; Charlie 1 ETH</p><p>任何其他交易订单都不起作用，重要的是每个人都同意这一点。</p><p>因此，矿工还负责验证区块链网络上的加密货币交易并将其添加到分类账中。重要的是，这个过程可以防止数字货币的<a href="https://en.wikipedia.org/wiki/Double-spending">双重支出</a>。</p><h2 id="为什么有人会成为矿工？"><a href="#为什么有人会成为矿工？" class="headerlink" title="为什么有人会成为矿工？"></a>为什么有人会成为矿工？</h2><p>就像实物货币一样，当有人执行交易时，必须更新区块链的状态以反映所涉及的每个账户的借方&#x2F;贷方。</p><p>然而，数字平台容易受到攻击，并且可以被操纵。因此，矿工不仅提出新区块并验证所有交易，他们还需要出示合法性证书，证明他们提议的区块中的所有交易都是有效的。</p><p>生成此证书是一项计算难度大且复杂的挑战。这就是所有工作量证明的内容。我们将在稍后的教程中对此进行更深入的讨论，但现在，只知道生成此证书非常困难。</p><p>但是，有了合法性证书，第三方就很容易验证它是否有效。</p><p>对于在生产这些证书和执行交易方面辛勤工作的矿工，他们以新币的形式获得奖励。在以太坊中，当矿工成功挖出一个区块时，他们会因辛勤工作而获得 2 ETH。以太坊以 5 ETH 的整体奖励开始，但随着 2017 年拜占庭升级(Byzantium upgrade)而降低到 3 ETH，然后随着 2019 年君士坦丁堡升级(Constantinople upgrade)再次降至 2 ETH。</p><p>由于去中心化系统缺乏中央权威，因此挖矿过程对网络的安全性和有效性至关重要。因此，挖矿奖励作为参与交易验证过程的激励。</p><h2 id="谁能成为矿工？"><a href="#谁能成为矿工？" class="headerlink" title="谁能成为矿工？"></a>谁能成为矿工？</h2><p>从技术上讲，任何人都可以通过运行以太坊节点软件成为以太坊上的矿工。然而，并不是每个人都能从以太坊中获利。</p><p>在大多数情况下，矿工购买专门的硬件来开采有利可图。普通计算机不太可能获得足够的采矿奖励来支付采矿相关的电气和硬件成本。</p><h2 id="采矿成本"><a href="#采矿成本" class="headerlink" title="采矿成本"></a>采矿成本</h2><ul><li>构建和维护硬件所需的硬件成本</li><li>为采矿设备供电的电力成本</li><li>支持采矿设备的潜在设备成本（冷却器、通风机、能量监视器、电线、太阳能农场等）</li></ul><p>要探索采矿盈利能力，您可以使用<a href="https://etherscan.io/ether-mining-calculator">这样的计算器</a></p><h2 id="以太坊交易是如何开采的？"><a href="#以太坊交易是如何开采的？" class="headerlink" title="以太坊交易是如何开采的？"></a>以太坊交易是如何开采的？</h2><ol><li>用户从他们的账户签署交易请求</li><li>交易通过节点广播到以太坊网络</li><li>在听到新交易后，网络中的每个节点都会将交易添加到它们的本地 mempool（内存池）中。内存池是节点已经听说但尚未包含在区块中的交易列表。</li><li>在某些时候，矿工将大量交易分组到一个潜在的区块中，以最大限度地提高他们赚取的交易费用，同时保持在区块气体限制之下。然后，<ol><li>矿工验证每笔交易的有效性。这包括检查没有人试图转移他们不拥有的以太，或者签名无效，或者请求格式不正确等。</li><li>然后矿工在他们的以太坊虚拟机（EVM）的本地副本上执行交易。它将每个此类请求的交易费用奖励给他们自己的账户。</li><li>在区块中的所有交易都经过验证并在其本地 EVM 上执行之后，矿工开始为整个区块创建工作证明合法性证明。</li></ol></li><li>最终，矿工完成为区块生成合法性证书，其中包括用户的交易。然后矿工将完成的区块广播给全世界，其中包括证书和区块链的新状态信息。</li><li>其他节点听到有关新块的消息。他们验证证书（这很容易做到），在他们的 EVM 本地副本上执行区块中的所有交易，并验证他们的 EVM 状态是否与矿工提议的状态相匹配。</li><li>一旦其他节点验证了矿工提出的所有建议，他们就会将此块添加到他们的区块链节点，并接受新的 EVM 状态作为“区块链的当前状态”。</li><li>每个节点都会从其本地内存池中删除块中包含的交易。</li><li>这个过程重复。</li></ol><h2 id="不同的采矿方法"><a href="#不同的采矿方法" class="headerlink" title="不同的采矿方法"></a>不同的采矿方法</h2><p>在该技术的早期，当成为一名矿工非常容易时，大多数矿工使用在台式机和笔记本电脑上运行的基于 CPU 的挖矿。然而，在当今时代，CPU 挖矿非常缓慢且不切实际，因为即使是少量的挖矿奖励也可能需要几个月的时间，同时还要持续以 100% 的容量运行 CPU 并支付高昂的电力成本。</p><p>基于 GPU 的挖掘是当今最常见的方法。这种方法可以通过将多个 GPU 放在一个采矿设备下，使它们全部并行工作，从而提高一个设备的整体容量和吞吐量，从而最大限度地提高计算能力。</p><p>专用集成电路（ASIC）挖矿也很受欢迎。这些是专门为挖掘以太坊而设计的硬件芯片。您可以在线为最流行的区块链网络购买 ASIC。然而，它们很昂贵，而且随着越来越多的矿工加入网络并且挖矿变得更加困难，硬件很快就会过时。一个全新的 ASIC 通常最多只能使用 1-2 年。</p><p>目前正在增长的另一个选择是云挖矿，它允许个人矿工利用专用挖矿设施的力量，而无需拥有任何硬件。</p><h2 id="矿池"><a href="#矿池" class="headerlink" title="矿池"></a>矿池</h2><p>大多数个体矿工没有足够的资源来建立拥有数千个 GPU 和 ASIC 的大型采矿设施。矿池允许矿工组合他们的计算资源，以增加他们挖掘区块的机会。如果矿池中的任何人成功开采了一个区块，则奖励将根据他们为矿池贡献的计算能力按比例分配给矿池中的每个人。</p><h2 id="挖矿可视化演示"><a href="#挖矿可视化演示" class="headerlink" title="挖矿可视化演示"></a>挖矿可视化演示</h2><p>观看此视频以获得采矿过程的可视化演示。</p><p><a href="https://www.youtube.com/watch?v=zcX7OJ-L8XQ">视频</a></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>以下是额外推荐的但可选的阅读和查看，以了解有关采矿的更多信息：</p><ul><li><a href="https://docs.ethhub.io/using-ethereum/mining/">挖以太坊意味着什么？</a></li><li><a href="https://etherscan.io/stat/miner?range=7&blocktype=blocks">顶级以太坊矿工</a></li><li><a href="https://etherscan.io/ether-mining-calculator">Etherscan 挖矿计算器</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 以太坊目前使用什么共识机制？</p><p>A: 工作证明(PoW: Proof of Work)</p><p>B: 股权证明(PoS: Proof of Stake)</p><p>C: 权威证明(PoA: Proof of Authority)</p></li><li><p>🤔 网络中存在矿工，保证用户可控</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 矿工获得报酬以开采区块</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 以太坊的挖矿奖励大致为：</p><p>A: 2 ETH&#x2F;Block</p><p>B: 5 ETH&#x2F;Block</p><p>C: 1 ETH&#x2F;Block</p></li><li><p>🤔 成为矿工对任何人来说都是非常有利可图的</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 Mempool 是已挖掘的交易列表</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 哪种挖矿方式更赚钱？</p><p>A: 使用 CPUs</p><p>B: 使用 GPUs</p><p>C: 使用 APUs</p></li><li><p>🤔 专门为挖以太坊而设计的芯片是什么？</p><p>A: APUs</p><p>B: ASICs</p><p>C: GPUs</p></li><li><p>🤔 矿池帮助个体矿工结合他们的计算工作来增加挖掘区块的机会</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 以太坊将在 2022 年后转向权威证明(PoA)</p><p>A: 是的</p><p>B: 错误</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>B</li><li>A</li><li>A</li><li>B</li><li>B</li><li>B</li><li>B</li><li>A</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>什么是Gas?</title>
    <link href="http://blog.julysong.com/2022/08/25/web3-sophomore-level2/"/>
    <id>http://blog.julysong.com/2022/08/25/web3-sophomore-level2/</id>
    <published>2022-08-25T07:32:20.000Z</published>
    <updated>2025-02-20T06:39:02.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/482b1e3d-fd7c-4008-9bca-a17d1bbee5f7">What is Gas?</a></p><p>翻译: JulySong</p></blockquote><p>Gas 是理解以太坊网络的最重要和最基本的方面之一。</p><blockquote><p>天然气是允许它（以太坊）运行的燃料，就像汽车需要汽油才能运行一样。</p></blockquote><p>在浏览新生跟踪教程时，您可能已经注意到在以太坊网络上进行的交易需要用户支付交易费用。</p><ul><li>这个交易费是怎么计算的？</li><li>您需要为一笔交易支付多少 ETH？</li><li>为什么有些交易比其他交易更昂贵？</li><li>为什么会有 Gas 费？</li></ul><p>这些问题的答案在于 gas 的概念。</p><p>最近的升级，即 2021 年 8 月的伦敦升级，略微改变了交易费用的计算方式和天然气的运作方式。出于这个原因，我们将把本教程分为两个部分：</p><ul><li>伦敦前升级</li><li>伦敦后升级</li></ul><p>Pre-London Upgrade 比 Post-London Upgrade 更容易理解并且更容易理解，并且也为升级提供了动力。</p><h2 id="Gas-一般概念"><a href="#Gas-一般概念" class="headerlink" title="Gas: 一般概念"></a>Gas: 一般概念</h2><p>就像秒是一个时间单位，而米是一个距离单位一样，gas 本身就是以太坊网络上的一个计算单位。</p><p>气体单位用于衡量在以太坊上执行交易所需的计算量。由于每笔交易都需要一些计算资源来执行，因此需要一笔费用，通常称为 Gas 费用或交易费用。</p><p>汽油费以以太坊的本地货币——以太币或 ETH 支付。汽油费的计算方式在伦敦升级前后略有不同。</p><blockquote><p>注意：通常当有人说“Gas”时 - 他们指的是“Gas Fees”而不是单位本身。但是，出于本教程的目的，我们在技术上是正确的，在提到单位时说“Gas”，在提到 Ether 中的费用时说“Gas Fees”。</p></blockquote><h2 id="伦敦前升级"><a href="#伦敦前升级" class="headerlink" title="伦敦前升级"></a>伦敦前升级</h2><p>在伦敦升级发生之前，您需要为一笔交易支付多少以太币是使用一个简单的公式计算出来的。</p><p><code>gas fees = gas spent * gas price</code></p><ul><li>Gas Spent 是用于执行交易的气体总量（以气体单位为单位）</li><li>Gas Price 是你愿意为每个执行的 Gas 单位支付的以太币数量</li></ul><p>Gas 价格以 gwei 计价 - 一种 ETH 的计价单位。</p><p>1 Gwei &#x3D; 0.000000001 ETH</p><p>1 ETH &#x3D; 10^9 Gwei</p><p>因此，与其说你的 gas 价格是 0.000000001 ETH，不如说你的 gas 价格是 1 Gwei。</p><blockquote><p>Gwei 代表 Giga-Wei，等于 1,000,000,000 (10^9) wei。Wei 是 ETH 的最小面额。1 ETH &#x3D; 10^18 Wei。</p></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>就执行所需的气体量而言，最便宜的交易只是将 ETH 从一个账户转移到另一个账户。这笔交易花费了 21,000 个气体单位。</p><p>假设 Alice 想向 Bob 支付 1 ETH。天然气成本为 21,000 gas。假设 gas 价格为 200 Gwei。</p><p>所以，<code>gas fees = 21,000 * 200 = 4,200,000 Gwei = 0.0042 ETH</code></p><p>因此，当 Alice 汇款时，会从她的账户中扣除 1.0042 ETH，而 Bob 将收到 1 ETH。0.0042 ETH 费用归于挖掘包含 Alice 交易的区块的矿工。</p><p>您可能想知道 gas 价格是如何设置为 200 Gwei 的？天然气价格设置多少取决于用户。具有较高 gas 价格的交易具有更高的优先级被包含在一个区块中，因为矿工首先获得更高的小费。因此，天然气价格基本上就像公开拍卖或贿赂矿工一样。谁愿意向矿工支付最高价格或最高贿赂，他们的交易就会比价格较低的交易更快。</p><p>像 Metamask 这样的钱包可以根据当前网络条件为要执行的交易提供合理的 gas 价格估算——因此大多数用户不需要自己接触 gas 价格值。（不过，您可以通过 Metamask 设置启用修改）</p><h3 id="天然气成本计算"><a href="#天然气成本计算" class="headerlink" title="天然气成本计算"></a>天然气成本计算</h3><p>当智能合约被编译成字节码时，在部署到以太坊网络之前，它会被编译成 OPCODES。这些是可以直接在以太坊虚拟机上运行的简单操作。您可以将它们视为可以直接在 Intel 或 AMD CPU 上运行的基本操作。这些 OPCODES 包括基本操作，如 <code>ADD</code>, <code>MUL</code>, <code>DIV</code>, <code>SUB</code>, <code>SHA3</code>等.</p><p>每个 OPCODE 都有固定的 gas 成本。智能合约中特定功能的 gas 成本是其所有 OPCODES 的 gas 成本之和。 <a href="https://github.com/crytic/evm-opcodes">如果有兴趣，您可以在此处找到所有 OPCODE 及其相关 gas 费用的列表。</a>.</p><p>因此，与将 ETH 从一个账户转移到另一个账户这样的简单交易相比，需要更多操作码才能执行的更复杂的交易最终会使用更多的气体（单位）。</p><h3 id="气体限制"><a href="#气体限制" class="headerlink" title="气体限制"></a>气体限制</h3><p>现在，您可以想象存在许多功能，这些功能比仅将 ETH 从一个帐户发送到另一个帐户要复杂得多。那些涉及循环，或随机性，或依赖于用户输入。</p><p>对于此类函数，可能很难准确预测执行所需的气体量，因为它取决于其他变量。</p><p>因此，您可以指定一个上限，而不是在决定为交易支付多少费用时指定确切的 gas 成本。</p><p>Gas Limit 是指您愿意为交易使用的最大 Gas 量（单位）。这是由用户设置的。</p><p>同样，像 Metamask 这样的钱包提供了合理的估计。</p><p>如果您的交易使用的 gas 少于您的限额，则未使用的 gas 将退还到您的帐户。</p><p>因此，您的钱包在发送交易时必须有<code>gas limit * gas price</code>以太币来支付 gas。当交易被执行和开采时，任何未使用的 gas 都将被退还。</p><p>但是，如果您的交易使用的 gas 超过了您的限制，则交易将失败并且您的 gas 将消失。</p><h3 id="阻止气体限制"><a href="#阻止气体限制" class="headerlink" title="阻止气体限制"></a>阻止气体限制</h3><p>除了用户指定的每笔交易的气体限制外，以太坊网络还对单个区块中允许的最大气体量（单位）施加了限制。</p><p>这样做是为了确保每个块都保持在允许的计算成本范围内。由于更复杂的事务需要更长的时间来执行，这可以确保节点不会由于计算复杂性的增加而开始与网络的其余部分不同步。</p><h2 id="伦敦后升级"><a href="#伦敦后升级" class="headerlink" title="伦敦后升级"></a>伦敦后升级</h2><p>2021 年 8 月 5 日 - 伦敦升级在以太坊网络上实施。本次升级主要引入了三个好处：</p><ul><li>更好的汽油费估算</li><li>更快的交易包含</li><li>燃烧一定比例的 ETH 作为交易费用</li></ul><p>就本文而言，我们主要对前两点感兴趣。</p><p>在伦敦升级之前，像 Metamask 这样的钱包会根据过去的网络活动提供对 gas 价格的估计。每个钱包都使用自己的方法来做到这一点。具体来说，Metamask 扫描了以太坊上的最后 1000 个区块，并预测了您交易的 gas 价格。</p><p>然而，从伦敦升级开始，每个区块都设置了基本汽油价格费用。这是将您的交易包含在此区块中的每单位 gas 的最低价格。这是由网络根据对块空间的需求本地计算的。这些基本费用将继续被以太坊网络烧毁，因此永远摆脱该 ETH 以抵消发行。由于以太坊没有总体最大供应量（与比特币的最大供应量为 2100 万比特币不同），因此销毁有助于 ETH 供应量达到平衡，而不是无限膨胀。</p><p>除了基本费用外，还引入了小费（优先费用）的概念。随着基本费用被烧毁，提示用于补偿矿工执行和传播用户交易。大多数钱包都会自动设置，但您可以选择手动设置。更高的小费交易往往会获得更高的优先级。</p><p>此次升级后，gas 费用的计算公式更改为：</p><p><code>gas fees = gas spent * (base fees + priority fees)</code></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>回到前面的例子，如果 Alice 必须向 Bob 支付 1 ETH，那么 gas 成本（以单位为单位）为 21,000。假设基本费用为 100 Gwei，Alice 决定包含 10 Gwei 的小费。</p><p><code>total gas fees = 21,000 * (100 Gwei + 10 Gwei) = 2,310,000 Gwei = 0.00231 ETH</code></p><h3 id="可变块大小"><a href="#可变块大小" class="headerlink" title="可变块大小"></a>可变块大小</h3><p>在伦敦升级之前，所有区块的区块气体限制是恒定的。每个区块的最大容量为 15M 气体。在需求量大的时候，这会导致糟糕的用户体验，因为区块正在满负荷运行，用户必须等待需求减少才能被包含在区块中。</p><p>升级为以太坊引入了可变大小的块。每个区块现在有一个 15M gas 的目标 gas 限制，但大小可以随着网络需求而增加或减少，最高可达 30M gas。</p><p>平均而言，网络通过修改区块大小和基本费用达到了 1500 万左右的平衡。</p><p>如果块气体大于 15M 目标，则增加下一个块的基本费用。同样，如果区块气体小于 15M 目标，则下一个区块的基本费用会降低。调整基本费用的金额取决于区块气体与 1500 万目标的距离。</p><p>花一些时间阅读最后几段并完全掌握它们 - 这是非常迷人的东西，但可能有点棘手。</p><h3 id="可变基本费用"><a href="#可变基本费用" class="headerlink" title="可变基本费用"></a>可变基本费用</h3><p>让我们看看在高网络需求时基本费用会发生什么变化。</p><p>如果超过目标 15M gas，则每个区块的基本费用最多增加 12.5%。这种指数增长使得区块气体无限期地保持在高位在财务上是不可行的，因此允许节点与网络保持同步，而不是不断地执行 30M 的气体块。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level2/1.png?raw=true"></p><p>在此示例中，第 2 块看到了从目标 15M 到 30M 的最大可能增长。结果，区块 3 的基本费用从 100 Gwei 增加到 112.5 Gwei，增加了 12.5%。</p><p>同样，由于区块 3 也达到了 30M gas 的最大限制，这是与目标的最大可能距离，因此区块 4 的基本费用再次增加了 12.5% 至 126.6 Gwei。等等…</p><p>这种情况一直在发生，到第 8 块时，基本费用为 202.7 Gwei。比 7 个街区前增加了 102.7%！到第 100 块时，基本费用为 10302608.6 Gwei——这太疯狂了（也是不现实的）。这意味着在区块 100 进行简单的 ETH 转账将花费您 (21000 * 10302608.6 Gwei) &#x3D; 216 ETH。</p><p>由于基本费用呈指数级增长，因此可以注意到极不可能看到完整块的扩展峰值。</p><p>需要注意的是，基础费用也最多降低了 12.5%，帮助峰值在流量开始放缓后恢复平衡。</p><h3 id="更好的气体估算"><a href="#更好的气体估算" class="headerlink" title="更好的气体估算"></a>更好的气体估算</h3><p>相对于 Pre-London 升级机制，这种基本费用机制的改变使得费用预测更加可靠。按照上表，要在第 9 个区块创建交易，钱包可以让用户 100% 确定地知道要添加到下一个区块的最大基本费用为 <code>current base fees (base fees of prev block) * 112.5%</code> &#x3D; <code>202.8 * 112.5/100 </code>or <code>228.1 Gwei</code>. 相反，可以确定最低基本费用，因为知道减少只能是 12.5%：<code>current base fees (base fees of prev block) * 87.5%</code> &#x3D; <code>202.8 * 87.5/100</code> or <code>177.45 Gwei</code>.</p><p>因此，钱包现在知道在提供估算时提供给用户的基本费用的最小和最大范围。最小值是 <code>current base fees * 87.5%</code>, 最大值是: <code>current base fees * 112.5%</code> 然后用户可以调整矿工的小费，这通常是基本费用的一小部分。</p><h2 id="气体为什么存在？"><a href="#气体为什么存在？" class="headerlink" title="气体为什么存在？"></a>气体为什么存在？</h2><p>汽油费有助于保持以太坊网络的安全。通过对网络上执行的每次计算收取费用，可以防止不良行为者向网络发送垃圾邮件。</p><p>为了避免智能合约中的意外或恶意无限循环，这将导致所有以太坊节点永远卡住，交易的气体限制设置了交易可以使用多少计算的限制。</p><p>像这样的代码将耗尽所有提供的气体，达到限制，然后交易将失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Gas &#123;</span><br><span class="line">    uint public i = 0;</span><br><span class="line"></span><br><span class="line">    // 用完你发送的所有气体会导致你的交易失败。</span><br><span class="line">    // 状态更改已撤消。</span><br><span class="line">    // 消耗的 Gas 不退还。</span><br><span class="line">    function forever() public &#123;</span><br><span class="line">        // Here we run a loop until all of the gas are spent</span><br><span class="line">        // and the transaction fails</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            i += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使这一切成为可能的基本单位是气体。</p><h2 id="降低燃气费"><a href="#降低燃气费" class="headerlink" title="降低燃气费"></a>降低燃气费</h2><p>如今，以太坊的高额费用是一个热门话题。以太坊社区已庄严宣誓不会损害网络的去中心化或安全性。因此，进行了有利于安全性的权衡，这导致以太坊网络目前的交易费用高于其他区块链（如 Solana），从而以牺牲安全性和去中心化为代价，进行了有利于降低费用的权衡。</p><p>以太坊的基本目标是成为一个能够执行智能合约的高度安全和高度去中心化的区块链网络。</p><p>但是，如果用户必须继续花费数百美元来移动一美元，那么这些都不重要。</p><p>因此，有很多事情正在进行中，其中一些已经可用，以降低 gas 费用并改善用户体验。</p><p>首先，以太坊 2.0（也称为 Eth2）将提供的网络升级最终将解决一些气体问题，这反过来将使网络能够每秒处理数千笔交易并在全球范围内扩展。</p><p>此外，在第 2 层扩展方面正在进行大量工作。稍后我们将更深入地了解第 2 层扩展和第 2 层平台，但本质上它们是将智能合约的繁重计算方面转移到其他地方的网络，并使用以太坊主网作为最终结算层，从而继承了安全性和以太坊的去中心化优势，并为用户保持低 gas 费和高交易速度。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>推荐使用以下资源（但可选）阅读&#x2F;查看以了解有关气体的更多信息：</p><ul><li><a href="https://www.youtube.com/watch?v=AJvzNICwcwc">视频：以太坊气体解释</a></li><li><a href="https://ethereum.org/en/history/#london">伦敦升级</a></li><li><a href="https://medium.com/coinmonks/8-ways-of-reducing-the-gas-consumption-of-your-smart-contracts-9a506b339c0a">智能合约中的气体优化</a></li><li><a href="https://ethereum.org/en/developers/docs/scaling/layer-2-rollups/">有关第 2 层扩展的更多信息</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 以太坊网络上最便宜的交易是 $ETH 的转账</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 如果 Alice 想向 Bob 发送 1 ETH，假设 gas 价格为 100 Gwei，Alice 在交易费用中支付了多少 ETH（假设伦敦 ugprade 之前）？</p><p>A: 0.0021 ETH</p><p>B: 2100000 ETH</p><p>C: 0.021 ETH</p></li><li><p>🤔 今天花费 100 Gwei 的交易明天可以花费 200 Gwei</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 交易的 gas 价格值在伦敦升级之前是固定的</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 伦敦分叉发生在以太坊的伦敦服务器上</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 在伦敦分叉之后，向网络发送交易所需的最低费用是多少？</p><p>A: 基本费用</p><p>B: 优先费用</p><p>C: 天然气价格</p></li><li><p>🤔 您可以使用 Metamask 之类的钱包更改&#x2F;选择要为交易支付的最大汽油费</p><p>A: 是的</p><p>B: 错误</p></li><li><p>🤔 今天以太坊网络上可能的最大块大小限制是多少？</p><p>A: 10M Gas</p><p>B: 30M Gas</p><p>C: 15M Gas</p></li><li><p>🤔 哪个版本的以太坊网络为网络提供了更好的 gas 估算？</p><p>A: 伦敦前叉</p><p>B: 后伦敦叉</p></li><li><p>🤔 汽油费的概念对网络不利</p><p>A: 是的</p><p>B: 错误</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>A</li><li>A</li><li>B</li><li>B</li><li>A</li><li>A</li><li>B</li><li>B</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>React 和 Next.js 简介</title>
    <link href="http://blog.julysong.com/2022/08/24/web3-sophomore-level1/"/>
    <id>http://blog.julysong.com/2022/08/24/web3-sophomore-level1/</id>
    <published>2022-08-24T09:50:17.000Z</published>
    <updated>2025-02-20T06:39:02.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://learnweb3.io/courses/c1d7081b-63a9-4c6e-b35c-9fcbbad418b2/lessons/8f589065-2016-42ef-ae2d-0f56d98c79ab">Just Enough React (and Next.js)</a></p><p>翻译: JulySong</p></blockquote><p>在新手篇教程中，我们构建了一个非常简单的 dApp，它使用了 HTML、CSS 和一些 Javascript。然而，在现实世界中，这些类型的“普通”网站实现已成为过去。</p><p>今天，我们使用 Web 框架来简化 Web 开发过程。它更简单吗？取决于你从谁的角度来看。如果您刚刚开始并且以前从未这样做过，那么您可能需要一些时间才能理解所有必要的概念。但是，从长远来看，您会感谢自己并为您花时间学习它而感到高兴。</p><p>当今使用的最大和最常见的 Web 框架是：</p><ul><li><a href="https://reactjs.org/">React</a></li><li><a href="https://angular.io/">Angular</a></li><li><a href="https://vuejs.org/">Vue</a></li></ul><p>尽管它们各有优缺点，但 React 迄今为止已经席卷了 Web 开发世界。在 Web3 领域也是如此，其中 React 是构建 dApp 最常用的 Web 框架。在整个入门篇教程以及所有后续教程中，我们将使用大量 React，因此将此级别视为 React 速成课程，它将教你足够的入门知识。这并不是要替代在专注于 Web2 教学的平台上学习 React，而是用作了解入门需要多少知识的指南，这样您就不会陷入教程地狱。😅</p><blockquote><p>实际上，我们将使用 Next.js——它是 React 本身的扩展——但稍后会详细介绍。让我们先学习一些 React。</p></blockquote><h2 id="WTF-是-React？"><a href="#WTF-是-React？" class="headerlink" title="WTF 是 React？"></a>WTF 是 React？</h2><p>React 是一个 Web 框架，可以轻松构建和推理 Web 应用程序的“视图”。“视图”是屏幕上显示的内容，它如何变化、如何更新等。React 本质上只是为您提供了一种模板语言，您可以创建返回 HTML 的 Javascript 函数。</p><p>普通的 Javascript 函数返回 Javascript 风格的东西——字符串、数字、布尔值、对象等。React 基本上结合了 Javascript 和 HTML 来产生一种他们称为 JSX 的语言。在 JSX 中，类似 Javascript 的函数返回 HTML 而不是常规的 Javascript 内容。基本上就是这样。</p><p>返回 HTML 的 Javascript 函数的组合称为组件。组件是用 JSX 编写的。虽然一开始看起来很尴尬，但一旦你习惯了，它们实际上很容易使用。</p><p>这是一个简单组件的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ShoppingList() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;shopping-list&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Shopping List&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li&gt;Apples&lt;/li&gt;</span><br><span class="line">          &lt;li&gt;Bananas&lt;/li&gt;</span><br><span class="line">          &lt;li&gt;Grapes&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好，但这与 HTML 没有太大区别。但是，如果您想基于数组呈现项目列表怎么办？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ShoppingList() &#123;</span><br><span class="line">    const items = [&quot;Apples&quot;, &quot;Bananas&quot;, &quot;Grapes&quot;]</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;shopping-list&quot;&gt;</span><br><span class="line">        &lt;h1&gt;Shopping List&lt;/h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;items.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;)&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哇，看那个！我们只是在 HTML 中使用了 Javascript。在 JSX 中，您可以通过将 JS 代码包装在花括号<code>&#123;</code> 和 <code>&#125;</code> 中来在 HTML 中编写 Javascript。但实际上，如果您再考虑一下，您就会意识到正在发生的事情。<code>.map()</code> 是一个 Javascript 函数，它遍历一个数组并为每个项目返回一些内容。在这种情况下，它循环遍历 <code>items</code> 数组并返回一个 <code>li</code> 元素，该元素具有其中的 Javascript 变量 <code>item</code> 的值，即 HTML。得到它？🤔</p><p>在我们的组件内部，我们基本上嵌入了另一个组件。map 函数是一个返回 HTML 的 JS 函数。它是一个组件。即使它没有明确定义为顶级函数，它仍然是一个组件。</p><p>将组件嵌入到其他组件中是 React 的强大功能。这称为组合(<code>Composition</code>)。我们将多个返回 HTML 的 Javascript 函数组合在一起，并从中构建一个组合的 HTML 文档，该文档将显示在 Web 应用程序上。</p><h3 id="组件之间的数据传递"><a href="#组件之间的数据传递" class="headerlink" title="组件之间的数据传递"></a>组件之间的数据传递</h3><p>如果组件只是静态的，它们就不是很有用。当然，遍历数组和其他东西都很好，但当今大多数 Web 应用程序都不是静态文档。今天的大多数 Web 应用程序都会从某种服务器、数据库或区块链中动态获取数据。这意味着经常需要相同的组件来显示不同的数据。</p><p>拥有组件的主要用例是能够编写可重用的代码，并且可以在其中包含不同的信息，而无需再次重写整个代码。</p><p>让我们看一个例子。这两个代码哪个更易读？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;cards&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;img_avatar.png&quot; alt=&quot;Avatar&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;h4&gt;&lt;b&gt;Alice&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;Frontend Developer&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;img_avatar.png&quot; alt=&quot;Avatar&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;h4&gt;&lt;b&gt;Bob&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;Backend Developer&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;card&quot;&gt;</span><br><span class="line">      &lt;img src=&quot;img_avatar.png&quot; alt=&quot;Avatar&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;h4&gt;&lt;b&gt;Charlie&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">        &lt;p&gt;Full Stack Developer&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function Cards() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;cards&quot;&gt;</span><br><span class="line">            &lt;!--Data is passed to children through HTML attributes--&gt;</span><br><span class="line">            &lt;Card name=&quot;Alice&quot; job=&quot;Frontend Developer&quot; /&gt;</span><br><span class="line">            &lt;Card name=&quot;Bob&quot; job=&quot;Backend Developer&quot; /&gt;</span><br><span class="line">            &lt;Card name=&quot;Charlie&quot; job=&quot;Full Stack Developer&quot; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Card receives an object as an argument</span><br><span class="line">// We can destructure the object to get specific variables</span><br><span class="line">// from inside the object - name and job</span><br><span class="line">function Card(&#123;name, job&#125;) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">            &lt;img src=&quot;img_avatar.png&quot; /&gt;</span><br><span class="line">            &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">                &lt;h4&gt;&lt;b&gt;&#123;name&#125;&lt;/b&gt;&lt;/h4&gt;</span><br><span class="line">                &lt;p&gt;&#123;job&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯 HTML 示例重复使用相同的代码 3 次，尽管真正改变的只是人名和他们的职位。</p><p>在 JSX 中，我们可以将每个 <code>Card</code> 抽象为一个组件，该组件从其父组件（在本例中为 <code>Cards</code>）获取某些数据。父组件通过类似 HTML 的属性（<code>name=&quot;Alice&quot;</code>）将数据传递给子组件，子组件访问它们的值就像 JS 函数接收 JS 对象作为参数一样。然后 <code>Card</code> 组件可以根据从父级接收到的内容返回带有可变数据的 HTML。</p><p>这段代码更容易重用和扩展。想要稍微改变所有卡片的外观吗？只需修改一个组件！并非所有复制粘贴的 HTML。</p><h3 id="交互式组件"><a href="#交互式组件" class="headerlink" title="交互式组件"></a>交互式组件</h3><p>好的，所以我们现在可以在组件之间传递数据。这一切都很好，但我们还没有添加交互性。诸如在单击按钮或在输入框中键入文本时能够运行一些代码等。</p><p>值得庆幸的是，在 Javascript 中，函数可以在其中包含函数。例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function someFunc() &#123;</span><br><span class="line"></span><br><span class="line">    function otherFunc() &#123;</span><br><span class="line">        console.log(&quot;Hello!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    otherFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someFunc(); // will print &quot;Hello!&quot;</span><br><span class="line"></span><br><span class="line">otherFunc(); // will throw an error! undefined here</span><br></pre></td></tr></table></figure><p><code>otherFunc</code> 只能在 <code>someFunc</code> 自身内部使用。这是常规 Javascript 中很少使用的功能，但在使用 React 时使用非常频繁。让我们通过一个例子来看看为什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Button() &#123;</span><br><span class="line"></span><br><span class="line">    function handleClick() &#123;</span><br><span class="line">        console.log(&quot;Hello&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;button</span><br><span class="line">            className=&quot;button&quot;</span><br><span class="line">            onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">            Click Me!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们有一个名为 <code>Button</code> 的 JSX 函数。在这个函数中，我们有另一个函数叫做 <code>handleClick</code>。在 HTML <code>&lt;button&gt;</code> 标记中，我们指定 <code>onClick=&#123;handleClick&#125;</code> 以便在单击按钮时调用 <code>handleClick</code> 函数。此功能仅在 <code>Button</code> 组件内部可用。单击 Web 应用程序上的按钮将在浏览器控制台中打印 <code>Hello</code>。这就是我们使用 React 构建交互式网站的方式！</p><p>这个例子仍然相当简单，因为 <code>handleClick</code> 没有参数。如果我们想在用户输入输入框时在控制台中打印文本怎么办？我们如何将文本传递给函数？</p><p>就是这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function PrintTypedText() &#123;</span><br><span class="line"></span><br><span class="line">    function handleOnChange(text) &#123;</span><br><span class="line">        console.log(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;input</span><br><span class="line">            type=&quot;text&quot;</span><br><span class="line">            onChange=&#123;(e) =&gt; handleOnChange(e.target.value)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML <code>input</code>元素提供了一个方便的事件侦听器 - <code>onChange</code> - 每次该输入框中的文本发生更改（键入新字符、删除字符等）时都会触发该事件侦听器。</p><p>但是，除了触发一个函数之外，它还传递了更改的 HTML 元素（此处称为 <code>e</code>）。然后，我们可以获取 HTML 元素 <code>e</code> 并使用 <code>e.target.value</code> 提取文本，并将其作为参数传递给 <code>handleOnChange</code>，它将文本记录到浏览器控制台。</p><p>不同的 HTML 元素有不同的事件处理程序 - <code>onChange</code> 和 <code>onClick</code> 是两个例子，但还有更多！您可以在此处找到所有 HTML 事件的列表。</p><p>通过将 HTML 事件与函数处理程序相结合，我们可以做各种很酷的事情！从服务器加载数据、向服务器发送数据、更新我们的视图等。</p><h3 id="React-Hooks-useState-和-useEffect"><a href="#React-Hooks-useState-和-useEffect" class="headerlink" title="React Hooks - useState 和 useEffect"></a>React Hooks - useState 和 useEffect</h3><p>好的，我们已经讨论了组合、数据传递和交互性。但是，我们的应用程序仍然很愚蠢。交互性将允许您在单击按钮等时运行一些代码，但是如果您想更新一些变量怎么办？</p><p>不幸的是，以下不起作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function DoesNotWork() &#123;</span><br><span class="line">    let myNumber = 0;</span><br><span class="line"></span><br><span class="line">    function increment() &#123;</span><br><span class="line">        myNumber++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;myNumber&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;increment&#125;&gt;Increment!&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你点击多少次 <code>Increment</code> 按钮，屏幕上显示的数字都会卡在 <code>0</code>。这是因为当你从 React 组件中更新 <code>myNumber</code> 等常规变量时，即使值更新了，React 实际上并没有重新渲染 Web 应用程序的视图。它不会自动更新页面的 HTML 视图。</p><p>React Hooks 是“挂钩”到 React 组件的不同部分的函数，允许您执行诸如在变量的值更改时更新视图，或者在每次加载页面或更改变量时自动运行一些 JS 代码等操作，以及许多更酷的东西！我们将主要关注 95% 的时间使用的三个 React 钩子 - <code>useState</code>、<code>useEffect</code> 和 <code>useRef</code>。</p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>很多时候，您希望 HTML 视图根据某些变量的值变化进行更新。我们可以使用 <code>useState</code> 钩子来维护一个变量，该变量会在每次更改其值时自动重新渲染屏幕上显示的 HTML。这是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function ThisWorks() &#123;</span><br><span class="line">    // myNumber is the variable itself</span><br><span class="line">    // setMyNumber is a function that lets us update the value</span><br><span class="line">    // useState(0) initializes the React Hook</span><br><span class="line">    // with the starting value of 0</span><br><span class="line">    const [myNumber, setMyNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">    function increment() &#123;</span><br><span class="line">        // Sets the new value to the old value + 1</span><br><span class="line">        setMyNumber(myNumber + 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;myNumber&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;increment&#125;&gt;Increment!&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您尝试运行上述代码，您将看到 Web 应用程序的视图自动更新以反映变量的新值。</p><p><code>useState</code> 在 React 中使用创建的变量称为状态变量。状态变量可以更新并自动更新应用程序的视图。这是另一个在输入框中使用状态变量的示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function StateWithInput() &#123;</span><br><span class="line">    // myName is the variable</span><br><span class="line">    // setMyName is the updater function</span><br><span class="line">    // Create a state variable with initial value</span><br><span class="line">    // being an empty string &quot;&quot;</span><br><span class="line">    const [myName, setMyName] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">    function handleOnChange(text) &#123;</span><br><span class="line">        setMyName(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; handleOnChange(e.target.value)&#125; /&gt;</span><br><span class="line">            &lt;p&gt;Hello, &#123;myName&#125;!&lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 useState，我想说的最后一件事是，您还可以将它用于字符串和数字等基本类型。您还可以使用它们来存储数组和对象。但是，这里有一个警告。让我们看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function StateArrayDoesNotWork() &#123;</span><br><span class="line">  const [fruits, setFruits] = useState([]);</span><br><span class="line">  const [currentFruit, setCurrentFruit] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  function updateCurrentFruit(text) &#123;</span><br><span class="line">    setCurrentFruit(text);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addFruitToArray() &#123;</span><br><span class="line">    fruits.push(currentFruit);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; updateCurrentFruit(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;addFruitToArray&#125;&gt;Add Fruit&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;fruits.map((fruit, index) =&gt; (</span><br><span class="line">          &lt;li key=&#123;index&#125;&gt;&#123;fruit&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您尝试运行它，您将看到屏幕上没有显示任何水果。另请注意，我们没有在 <code>setFruits</code> 任何地方使用该函数，而只是尝试<code>.push</code> 使用 <code>fruits</code> 数组。</p><p>当我们尝试直接更新数组时，React 不会注册状态更改，这也被认为是无效的状态更新，可能导致应用程序出现意外行为。我们知道我们需要以某种方式使用 <code>setFruits</code>，但是如何使用呢？答案是我们实际上需要创建水果数组的副本，将水果添加到其中，并将状态变量完全设置为新数组。下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function StateArray() &#123;</span><br><span class="line">  const [fruits, setFruits] = useState([]);</span><br><span class="line">  const [currentFruit, setCurrentFruit] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  function updateCurrentFruit(text) &#123;</span><br><span class="line">    setCurrentFruit(text);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function addFruitToArray() &#123;</span><br><span class="line">      // The spread operator `...fruits` adds all elements</span><br><span class="line">      // from the `fruits` array to the `newFruits` array</span><br><span class="line">      // and then we add the `currentFruit` to the array as well</span><br><span class="line">      const newFruits = [...fruits, currentFruit]</span><br><span class="line">      setFruits(newFruits);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; updateCurrentFruit(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;addFruitToArray&#125;&gt;Add Fruit&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;fruits.map((fruit, index) =&gt; (</span><br><span class="line">          &lt;li key=&#123;index&#125;&gt;&#123;fruit&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您尝试运行上述代码，您将看到它按预期工作。每次按下按钮时，输入框中的当前文本都会添加到数组中，这会导致 HTML 上显示的水果列表更新。您可以继续添加任意数量的水果！</p><blockquote><p>对象也是如此。如果您的状态变量包含一个对象，您需要先创建该对象的副本，更新一个值，然后将状态变量完全设置为新对象。</p></blockquote><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>所以我们现在可以管理状态，太好了！状态变化也会影响我们渲染的 HTML，也很棒！</p><p>但是，通常需要在第一次加载页面时自动运行一些代码——也许是为了从服务器或区块链获取数据——并且还需要在某个状态变量发生变化时自动运行一些代码。</p><p>这些类型的功能称为副作用。React 为我们提供了 <code>useEffect</code> 钩子，它允许我们编写这些效果。<code>useEffect</code> 有两个参数——一个函数和一个依赖数组。函数是运行效果时运行的代码，依赖数组指定何时触发副作用。</p><p>考虑一个示例，当网站首次加载时，它想从服务器加载一些数据。这样做时，它希望向用户显示一个加载屏幕，然后在加载数据后，移除加载屏幕并显示实际内容。我们如何做到这一点？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function LoadDataFromServer() &#123;</span><br><span class="line">  // 创建一个状态变量来保存从服务器返回的数据</span><br><span class="line">  const [data, setData] = useState(&quot;&quot;);</span><br><span class="line">  // 创建一个状态变量来保持加载状态</span><br><span class="line">  const [loading, setLoading] = useState(false);</span><br><span class="line"></span><br><span class="line">  async function loadData() &#123;</span><br><span class="line">    // 将 `loading` 设置为 `true` 直到 API 调用返回响应</span><br><span class="line">    setLoading(true);</span><br><span class="line"></span><br><span class="line">    // 执行 API 调用以从服务器加载数据的虚构函数</span><br><span class="line">    const data = await apiCall();</span><br><span class="line">    setData(data);</span><br><span class="line"></span><br><span class="line">    // 我们有了数据，将 `loading` 设置为 `false`</span><br><span class="line">    setLoading(false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // loadData 是运行的函数</span><br><span class="line">  // 一个空的依赖数组意味着这段代码在页面加载时运行一次</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    loadData();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  // 当 `loading` 为 `true` 时显示 `&quot;Loading...&quot;`,</span><br><span class="line">  // 否则显示 `data`</span><br><span class="line">  return &lt;div&gt;&#123;loading ? &quot;Loading...&quot; : data&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您从链接运行上述代码，您将看到它在屏幕上显示 <code>Loading...</code> 5 秒钟，然后显示 <code>ABCDEF</code>。这是因为 <code>apiCall</code> 是一个只等待 5 秒然后返回字符串 <code>ABCDEF</code> 的函数。</p><p>首次加载页面时 <code>useEffect</code> 调用 <code>loadData</code> - 由于依赖项数组为空 - 并且状态变量使 HTML 呈现适当的内容。</p><p>这对于在页面第一次加载时运行代码很有用，但是每次状态变量的值发生变化时运行一些代码呢？例如，当您在 Facebook 上搜索某人的姓名时，Facebook 如何在您每次添加&#x2F;删除角色时获取并显示推荐？</p><p>您也可以使用 <code>useEffect</code> 来做到这一点，方法是在依赖数组中提供状态变量。每次该变量的值发生变化时，都会运行效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function DependentEffect() &#123;</span><br><span class="line">  const names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;, &quot;Emily&quot;];</span><br><span class="line"></span><br><span class="line">  const [recommendations, setRecommendations] = useState([]);</span><br><span class="line">  const [searchText, setSearchText] = useState(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    // 如果用户没有搜索任何内容，则不显示任何推荐</span><br><span class="line">    if (searchText.length === 0) &#123;</span><br><span class="line">      setRecommendations([]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 否则，查找推荐</span><br><span class="line">    else if (searchText.length &gt; 0) &#123;</span><br><span class="line">      const newRecs = names.filter((name) =&gt;</span><br><span class="line">        name.toLowerCase().includes(searchText.toLowerCase())</span><br><span class="line">      );</span><br><span class="line">      setRecommendations(newRecs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [searchText]);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; onChange=&#123;(e) =&gt; setSearchText(e.target.value)&#125; /&gt;</span><br><span class="line">      &lt;h2&gt;Recommendations:&lt;/h2&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;recommendations.map((rec, index) =&gt; (</span><br><span class="line">          &lt;li key=&#123;index&#125;&gt;&#123;rec&#125;&lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您运行上述代码并尝试输入一些字母，您将看到推荐列表会随着您在搜索框中添加&#x2F;删除新字符而自动更新。这是因为当您更新输入框时，<code>searchText</code> 的值会通过 <code>onChange</code> 处理程序进行更新，该处理程序会触发 <code>useEffect</code>，它会更新 <code>recommendations</code> 列表，从而更新 HTML 视图。</p><p>您也可以类似地创建依赖于多个状态变量的副作用，而不仅仅是一个。如果任何因变量发生变化，就会产生副作用。您只需将更多状态变量添加到依赖项数组即可。</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p><code>useRef</code> 是另一个比较常用的 React 钩子。它表面上与 <code>useState</code> 非常相似，但有一些实际上非常重要的细微差别使得这个 React Hook 学习起来很重要。</p><p><code>useRef</code> 变量的创建方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Component() &#123;</span><br><span class="line">    const myValue = useRef();</span><br><span class="line"></span><br><span class="line">    function updateMyValue(newValue) &#123;</span><br><span class="line">        myValue.current = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function printMyValue() &#123;</span><br><span class="line">        console.log(myValue.current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-没有重新渲染"><a href="#1-没有重新渲染" class="headerlink" title="1. 没有重新渲染"></a>1. 没有重新渲染</h5><p>与 <code>useState</code> 类似，<code>useRef</code> 挂钩也允许我们将变量存储在组件中，该变量可以随时间更新。但是，与状态变量不同，更新 ref 变量的值不会导致 HTML 视图重新呈现。</p><p>因此，如果您有一个 <code>useRef</code> 变量并且您在 HTML 视图中显示它的值，则更新该变量不会更新 HTML 视图。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function CounterWithRef() &#123;</span><br><span class="line">    const myNumber = useRef();</span><br><span class="line"></span><br><span class="line">    function increment() &#123;</span><br><span class="line">        if (myNumber.current !== undefined) &#123;</span><br><span class="line">            myNumber.current += 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            myNumber.current = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(myNumber.current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;&#123;myNumber&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;increment&#125;&gt;Increment!&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果您运行上面的代码，您会注意到每次单击按钮时，值都会递增并打印在浏览器控制台中，但 HTML 视图实际上并没有更新。事实上，HTML 视图不显示任何内容，因为 <code>myNumber.current</code> 的初始值是<code>undefined</code>的，并且由于 HTML 没有更新，因此就 HTML 而言，即使值实际上正在更新，它仍保持<code>undefined</code>。</p><h5 id="2-同步更新"><a href="#2-同步更新" class="headerlink" title="2. 同步更新"></a>2. 同步更新</h5><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/1.jpeg?raw=true"><br><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/2.jpeg?raw=true"></p><p>关于 <code>useState</code>，我们之前没有提到的是，当我们使用 <code>setXYZ</code> 函数更新状态变量时，它实际上不会立即更新。</p><p>在 React 中为状态变量设置新值是异步发生的，这意味着如果您在将状态变量设置为新值后立即尝试使用它的值，您可能实际上看不到新值被反映，因为它是异步发生的。</p><p>我们再来看看使用 <code>useState</code> 时的 Counter 例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function AsyncStateVariables() &#123;</span><br><span class="line">  const [number, setNumber] = useState(0);</span><br><span class="line"></span><br><span class="line">  function increment() &#123;</span><br><span class="line">    setNumber(number + 1);</span><br><span class="line">    console.log(number);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;number&#125;&lt;/p&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您运行它时，请注意视图上发生了什么以及控制台中发生了什么。当您第一次单击按钮时，状态变量应该更新为 <code>1</code> - 这就是视图上发生的情况，网页显示 <code>1</code>。但是如果您查看浏览器控制台，则会打印值 <code>0</code> 而不是 <code>1</code>。这种模式继续单击按钮。</p><p>这是因为 <code>setNumber</code> 调用是异步运行的，当我们到达 <code>console.log(number)</code> 行时，该值还没有更新，所以它打印了 <code>number</code> 的旧值。当它确实被更新时，HTML 被重新渲染以显示新值。</p><hr><p>另一方面，<code>useRef</code> 允许同步更新。当您使用 <code>myVar.current = newValue</code> 更新参考变量的值时，它会立即更新，并且没有延迟。这有时会派上用场。</p><h5 id="3-引用-DOM-元素"><a href="#3-引用-DOM-元素" class="headerlink" title="3. 引用 DOM 元素"></a>3. 引用 DOM 元素</h5><p><code>useRef</code> 让我们做的另一件很酷的事情是它允许我们直接引用 DOM 元素。这是 <code>useState</code> 无法实现的。</p><p>例如，您可以使用 <code>useRef</code> 直接引用<code>input</code>元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function InputFocus() &#123;</span><br><span class="line">  const inputRef = useRef();</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return &lt;input ref=&#123;inputRef&#125; type=&quot;text&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您运行上面的示例时，您会注意到页面加载后，该 <code>input</code> 元素已经在焦点上，即您可以开始输入而无需先单击它。这是因为我们持有对 <code>input</code> 元素的引用，并且由于有一个空的依赖数组，因此在页面加载时运行的 <code>useEffect</code> 专注于 <code>input</code> 元素。</p><h3 id="React-文件结构"><a href="#React-文件结构" class="headerlink" title="React 文件结构"></a>React 文件结构</h3><p>太好了，如果你刚刚开始使用 React，我们已经介绍了你应该知道的主要概念。但到目前为止，我们只处理了孤立的组件示例。一个实际的 React 项目是什么样子的？</p><p>React 应用程序通常使用 <code>create-react-app</code>（CRA）之类的工具创建。CRA 是一个命令行工具，可帮助您设置新的 React 项目并安装所有必需的依赖项，而无需手动创建所有样板。</p><p>当您使用 CRA 时，您最终会得到如下所示的文件结构。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/3.png?raw=true"></p><p><code>package.json</code> 文件应该是可识别的。CRA 通过 Node.js 环境工作，而 <code>package.json</code> 是创建所有依赖项和项目元数据的地方 - 与任何其他 Node.js 项目一样。</p><p><code>src/</code> 文件夹包含组件和 CSS 样式，基本上是任何特定于 React 的代码。这里的主要组件是<code>App.js</code>，它是您第一次设置 React 应用程序时创建的自动生成的组件。<code>index.js</code> 是 React 应用程序的主要入口点，但通常您不需要太多（或根本不需要）修改它。它只包含一些样板 React 代码，这些代码获取您的组件并将其转换为可以在浏览器中运行的实际 HTML 和 JS。</p><p>然后，<code>public/</code>文件夹默认只包含一个文件 - <code>index.html</code>。你通常不会自己碰这个。这是一个超级简单的准系统 HTML 文件。当一个 React 应用程序运行时，React 会在后台执行一些魔法，它会获取所有组件和 Javascript 代码，将其转换为可以在浏览器中运行的实际 HTML 和 JS，并用所有这些替换 <code>index.html</code> 的内容。然后，更新后的 <code>index.html</code> 就是向用户显示的内容。</p><p>如果您想将图像、字体、音乐等添加到您的网站，它们也会进入 <code>public/</code> 文件夹。<code>public/</code> 文件夹基本上包含您希望在您的网站上直接访问的所有内容。</p><p>例如，如果您在 <code>public/</code> 文件夹中添加了一个名为 <code>avatar.png</code> 的图像，那么您可以在 React 组件中显示该图像，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/avatar.png&quot; /&gt;</span><br></pre></td></tr></table></figure><p>虽然这可能看起来很奇怪，因为您的组件位于 <code>src/</code> 文件夹中而不是 <code>public/</code> 文件夹中——它起作用的原因是因为图像与 <code>index.html</code> 位于同一文件夹中——而 <code>index.html</code> 是你的 React 代码实际结束的地方向上。因此，当使用 <code>/avatar.png</code> 的相对路径引用图像时，它知道 <code>avatar.png</code> 必须在<code>public</code>文件夹内。</p><h2 id="后端时间"><a href="#后端时间" class="headerlink" title="后端时间"></a>后端时间</h2><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/4.png?raw=true"></p><p>到目前为止，我们一直在讨论 React，以及它的所有前端功能。但是后端呢？</p><p>React 不是后端框架，因此如果您想创建自己的 API 后端，则必须使用 Node.js 和 Express 之类的东西建立一个单独的项目。然而这很麻烦，就好像后端和前端是同一个项目一样，你可能有很多代码可以在两者之间重用和共享。此外，维护两个项目总是比只维护一个项目更难。</p><p>输入，Next.js</p><p>接下来是 React 的元框架。这是什么意思？嗯，React 本身就是一个构建 Web 应用程序的框架。接下来是一个 React 框架，它还引入了一些 React 没有的附加功能。</p><p>如果你了解 React，那么 Next 90% 是完全一样的东西，你可以很快开始使用它，但是我想谈谈 Next 带来的这些额外功能。</p><p>首先，正如标题和介绍所暗示的那样，Next 允许您在单个项目中编写前端和后端代码。您使用 React 构建前端，并使用与使用 Express 类似的语法编写后端 API 端点 - 但都在同一个项目中。</p><p>其次，Next 使创建多页 Web 应用程序变得非常容易。React 最初旨在帮助创建单页应用程序（SPA），组件非常适合！但是，如果您的网站有多个页面怎么办？例如<code>https://learnweb3.io/</code>和<code>https://learnweb3.io/about</code>和<code>https://learnweb3.io/tracks</code>等等。</p><p>为此，<code>React Router</code> 引入了诸如此类的库，这使之成为可能，但也有点麻烦。“下一步”通过允许基于文件名的自动页面路由大大简化了这一点。</p><p>最后，Next 还具有服务器端渲染 (SSR) 和静态站点生成 (SSG)。这些不是我们将在我们的曲目中使用的功能，所以我不会在这里花太多时间，但如果您想了解更多关于它们的信息，请随时阅读推荐阅读。</p><h3 id="Next-路由"><a href="#Next-路由" class="headerlink" title="Next 路由"></a>Next 路由</h3><p>在讨论创建后端服务器之前，我们将讨论路由，因为这将帮助您了解它是如何工作的。</p><p>与 <code>create-react-app</code> 类似，Next 有一个名为 <code>create-next-app</code> 的工具，可以自动帮助您轻松设置新的 Next.js 项目。</p><p>当您创建一个新的 Next.js 项目时，您最终会得到一个如下所示的文件结构：</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/5.png?raw=true"></p><p>这是很多文件！但别担心，其中很多与我们已经讨论过的 React 类似。</p><p><code>public/</code>文件夹的工作方式完全相同，但不包含 <code>index.html</code> 文件。但是，如果您想添加图像、图标、字体、音乐等，您可以将它们全部放在 <code>public/</code>文件夹中。</p><p><code>styles/</code> 文件夹是一个很好的补充，为您的所有 CSS 文件提供了一个专用位置。</p><p><code>pages/</code> 很棒。<code>_app.js</code> 是一个自动生成的文件，通常你不会自己去碰它，它设置了一些样板代码，允许 Next 渲染正确的组件。</p><p><code>pages/index.js</code> 是您网站的主页。基本上，文件 <code>pages</code> 夹中的每个文件都是您网站的路线。遵循 Javascript&#x2F;HTML 样式的命名约定，这意味着 <code>index</code> 文件是“主”文件。因此，<code>pages/index.js</code> 是您首次打开网站时将加载的视图。</p><p>如果您在 <code>pages</code> 文件夹下添加更多文件，例如名为 <code>about.js</code> 的文件 - 它将在 <code>YOUR_DOMAIN/about</code> 中可用（有趣的事实：LearnWeb3 的网站是使用 Next 创建的，这正是我们的<code>https://learnweb3.io/about</code> 页面工作）。</p><p>这很棒，因为您不必处理诸如 React Router 之类的事情，并且构建多页面网站就像在 <code>pages/</code>文件夹下创建一个新文件一样简单，Next 会自动为您生成基于文件名的路由。</p><p>您还可以通过在文件夹下创建子文件夹来进行多级路由 <code>pages/</code>。例如，类似 <code>pages/tracks/freshman.js</code> 的东西会有 route <code>YOUR_DOMAIN/tracks/freshman</code>。</p><h3 id="在-Next-中编写-API"><a href="#在-Next-中编写-API" class="headerlink" title="在 Next 中编写 API"></a>在 Next 中编写 API</h3><p><code>pages/</code> 下有一个特殊文件夹，但是它也是自动生成的。<code>pages/api</code> 文件夹。与呈现 HTML 视图的常规页面不同，<code>pages/api</code> 文件夹下的任何内容都充当 API 端点。</p><p>让我们看一下自动生成的 <code>pages/api/hello.js</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function handler(req, res) &#123;</span><br><span class="line">  res.status(200).json(&#123; name: &#x27;John Doe&#x27; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个非常类似于 Express 的功能。如果您要转到 <code>YOUR_DOMAIN/api/hello</code> - 而不是呈现 HTML 视图，这将返回一个 JSON 对象 <code>&#123;name: &#39;John Doe&#39;&#125;</code> - 这是一个超级简单的 API 端点。</p><p>与常规 HTML 视图类似，您可以通过创建新文件在 <code>pages/api</code> 下创建 API 端点，并且端点路由基于文件名。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望这篇文章对您有所帮助，并且可以作为速成课程。我故意在这里更多地关注 React 而不是 Next，因为习惯前端部分对我们来说将比后端部分更相关。此外，后端代码基本上是常规的 Javascript，而前端是 JSX，我想让你更熟悉它。</p><p>我列出了一些额外的阅读材料和视频，我建议这些阅读材料和视频可以更好地理解这些概念。与往常一样，如果您有任何问题，请在<a href="https://discord.gg/learnweb3">#web2-support</a> 的频道上留言，我们很乐意为您提供帮助。</p><h2 id="读物-视频"><a href="#读物-视频" class="headerlink" title="读物&#x2F;视频"></a>读物&#x2F;视频</h2><ul><li><a href="https://www.youtube.com/watch?v=hQAHSlTtcmY">30 分钟学会 React</a></li><li><a href="https://www.youtube.com/watch?v=Sklc_fQBmcs">Next.js in 100 Seconds &#x2F;&#x2F; 加上完整的教程</a></li><li><a href="https://scrimba.com/learn/learnreact">Scrimba 的完整 React 课程</a></li><li><a href="https://www.youtube.com/watch?v=mTz0GXj8NN0">Next.js 速成班</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 JSX 的强大之处是什么？</p><p>A: 它是 Javascript 的扩展，增加了静态类型</p><p>B: 它是 Javascript 的扩展，允许您从 JS 函数返回 HTML 元素</p><p>C: 它是一个 Web 框架，可以帮助您推断应用程序的视图</p></li><li><p>🤔 什么是组合(<code>Composition</code>)？</p><p>A: 它是多个组件的组合，以创建单个分层 HTML 文档</p><p>B: 它是 React 库的依赖构成</p><p>C: 这是 React 官方歌曲</p></li><li><p>🤔 你可以通过 props 向组件传递任意数据吗？</p><p>A: 是</p><p>B: 否</p></li><li><p>🤔 React 组件如何让你的代码更容易理解？</p><p>A: 通过使用 Github Copilot 自动为您生成代码</p><p>B: 通过数据传递实现组件的可重用性</p><p>C: 使用更简单的编程语言</p></li><li><p>🤔 以下代码在运行时会做什么？</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/6.png?raw=true"></p><p>A: 返回数字 3</p><p>B: 因错误而崩溃</p></li><li><p>🤔 点击增量按钮会发生什么？</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/7.png?raw=true"></p><p>A: 应用程序的视图将更新以显示新的递增值 num</p><p>B: 什么都不会发生</p><p>C: 应用程序会崩溃</p></li><li><p>🤔 为什么在 React 中使用状态变量（useState）？</p><p>A: 它们用于维护在值更改时重新呈现 HTML 的值</p><p>B: 它们只是语法糖，没有真正的用途</p><p>C: 它们是在 React 组件中定义变量的唯一方法</p></li><li><p>🤔 useEffect hook 只能在页面首次加载时运行？</p><p>A: 是</p><p>B: 否</p></li><li><p>🤔 点击开始按钮会发生什么？</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/sophomore-level1/8.png?raw=true"></p><p>A: <code>num</code>的值加一并且 HTML 视图更新以显示新值</p><p>B: 什么都没发生</p><p>C: React 应用程序陷入无限循环</p></li><li><p>🤔 useEffect 只能依赖一个值？</p><p>A: 是</p><p>B: 否</p></li><li><p>🤔 useRef 和 useState 有什么区别？</p><p>A: 对引用变量的更新是同步完成的，而对状态变量的更新是异步完成的</p><p>B: 没有区别</p><p>C: useRef 仅用于引用 DOM 元素，而 useState 用于维护变量值</p></li><li><p>🤔 在网页间路由方面，React 和 Next.js 的主要区别是什么？</p><p>A: React 自动进行基于文件的路由，而 Next 需要一个路由库</p><p>B: 它们完全一样</p><p>C: React 需要一个路由库，而 Next 自动执行基于文件的路由</p></li><li><p>🤔 如何在 Next.js 应用程序中编写 REST API 端点？</p><p>A: 通过在 pages&#x2F; 子目录中创建文件</p><p>B: 通过在 pages&#x2F;api&#x2F; 子目录中创建文件</p><p>C: 通过在 api&#x2F; 子目录中创建文件</p></li><li><p>🤔 React 组件在 JSX 中使用时必须以大写字母开头？</p><p>A: 是</p><p>B: 否</p></li></ol><blockquote><p>参考答案:</p><ol><li>B</li><li>A</li><li>A</li><li>B</li><li>B</li><li>B</li><li>A</li><li>B</li><li>C</li><li>B</li><li>A</li><li>C</li><li>B</li><li>A</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之入门篇</summary>
    
    
    
    <category term="web3系列之入门篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level9:NFT教程</title>
    <link href="http://blog.julysong.com/2022/08/04/web3-freshman-level9/"/>
    <id>http://blog.julysong.com/2022/08/04/web3-freshman-level9/</id>
    <published>2022-08-04T06:55:01.000Z</published>
    <updated>2025-02-20T06:39:02.268Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/nft-tutorial">https://www.learnweb3.io/tracks/freshman/nft-tutorial</a></p><p>翻译: JulySong</p></blockquote><hr><h2 id="喜欢视频？"><a href="#喜欢视频？" class="headerlink" title="喜欢视频？"></a>喜欢视频？</h2><p>如果您想从视频中学习，我们的 YouTube 上有本教程的录音。单击下面的屏幕截图观看视频，或继续阅读教程！<br><a href="https://www.youtube.com/watch?v=uwnAXAsd428"><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level9/1.png?raw=true"></a></p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>设置 Metamask(初学者轨道-<a href="https://github.com/LearnWeb3DAO/Crypto-Wallets">4 级</a>)</li><li>检查您的计算机是否有 Node.js。如果不是<a href="https://nodejs.org/en/download/">从这里下载</a></li></ul><h2 id="建造"><a href="#建造" class="headerlink" title="建造"></a>建造</h2><h3 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h3><p>为了构建智能合约，我们将使用<a href="https://hardhat.org/">Hardhat</a>。Hardhat 是专为全栈开发而设计的以太坊开发环境和框架。简单来说，您可以编写智能合约、部署它们、运行测试和调试代码。</p><ul><li>要设置安全帽项目，请打开终端并执行以下命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir NFT-Tutorial</span><br><span class="line">cd  NFT-Tutorial</span><br><span class="line">npm init --yes</span><br><span class="line">npm install --save-dev hardhat</span><br></pre></td></tr></table></figure><ul><li>在安装 Hardhat 的同一目录中运行：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat</span><br></pre></td></tr></table></figure><pre><code>- 选择`Create a Javascript project`- 按回车键已指定`Hardhat Project root`- 如果您想添加一个问题，请按 Enter 键`.gitignore`- 按回车键`Do you want to install this sample project&#39;s dependencies with npm (@nomicfoundation/hardhat-toolbox)?`</code></pre><p>现在你有一个安全帽项目准备好了！</p><p>如果您在 Windows 上，请执行此额外步骤并安装这些库：)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @nomicfoundation/hardhat-toolbox</span><br></pre></td></tr></table></figure><h2 id="编写-NFT-合约代码"><a href="#编写-NFT-合约代码" class="headerlink" title="编写 NFT 合约代码"></a>编写 NFT 合约代码</h2><p>让我们安装 Open Zeppelin 合约，在终端窗口中执行这个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @openzeppelin/contracts</span><br></pre></td></tr></table></figure><ul><li>在 contracts 文件夹中，创建一个名为 NFTee.sol 的新 Solidity 文件</li><li>现在我们将在 NFTee.sol 文件中编写一些代码。我们将导入<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol">Openzeppelin 的 ERC721 Contract</a>。ERC721 是创建 NFT 的最常用标准。在新生赛道中，我们只会使用 ERC721。在二年级课程中，您将详细了解 ERC721。所以别担心，如果你不明白一切:)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// 导入 o​​penzepplin 合约</span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span><br><span class="line"></span><br><span class="line">// GameItem is ERC721 表示我们正在创建的合约导入 ERC721 并遵循来自 openzeppelin 合约的 ERC721openzeppelin</span><br><span class="line">contract GameItem is ERC721 &#123;</span><br><span class="line"></span><br><span class="line">    constructor() ERC721(&quot;GameItem&quot;, &quot;ITM&quot;) &#123;</span><br><span class="line">        // mint an NFT to yourself</span><br><span class="line">        _mint(msg.sender, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译合约，打开终端并执行这些命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat compile</span><br></pre></td></tr></table></figure><p>如果没有错误，你很高兴:)</p><h2 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h2><p>让我们部署合约来<code>rinkeby</code>测试网络。为此，我们将编写一个部署脚本，然后配置网络。首先，创建一个新文件&#x2F;替换<code>scripts</code>文件夹下命名的默认文件<code>deploy.js</code>，并在其中编写以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 从 Hardhat 包导入 ethers</span><br><span class="line">const &#123; ethers &#125; = require(&quot;hardhat&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  /*</span><br><span class="line">    ethers.js 中的 ContractFactory 是用于部署新智能合约的抽象，</span><br><span class="line">    因此这里的 nftContract 是我们的 GameItem 合约实例的工厂。</span><br><span class="line">    */</span><br><span class="line">  const nftContract = await ethers.getContractFactory(&quot;GameItem&quot;);</span><br><span class="line"></span><br><span class="line">  // 这里我们部署合约</span><br><span class="line">  const deployedNFTContract = await nftContract.deploy();</span><br><span class="line"></span><br><span class="line">  // 打印部署合约的地址</span><br><span class="line">  console.log(&quot;NFT Contract Address:&quot;, deployedNFTContract.address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用main函数，如果有错误就catch</span><br><span class="line">main()</span><br><span class="line">  .then(() =&gt; process.exit(0))</span><br><span class="line">  .catch((error) =&gt; &#123;</span><br><span class="line">    console.error(error);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>现在在文件夹中创建一个<code>.env</code>文件<code>NFT-Tutorial</code>并添加以下行。使用评论中的说明获取您的 Alchemy API 密钥和 Rinkeby 私钥。确保您获得 rinkeby 私钥的帐户由 Rinkeby 以太币提供资金。你可以在这里得到一些：https :&#x2F;&#x2F;<a href="http://www.rinkebyfaucet.com/">www.rinkebyfaucet.com/</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 跳到 https://www.alchemyapi.io 注册</span><br><span class="line"># 在其仪表板中创建一个新应用并选择网络为 Rinkeby，并将“add-the-alchemy-key-url-here”替换为其密钥 url</span><br><span class="line">ALCHEMY_API_KEY_URL=&quot;add-the-alchemy-key-url-here&quot;</span><br><span class="line"></span><br><span class="line"># 将此私钥替换为您的 RINKEBY 帐户私钥</span><br><span class="line"># 要从 Metamask 中导出您的私钥，请打开 Metamask 并</span><br><span class="line"># 转到 Account Details &gt; Export Private Key</span><br><span class="line"># 请注意不要将真实的 Ether 放入测试帐户</span><br><span class="line">RINKEBY_PRIVATE_KEY=&quot;add-the-rinkeby-private-key-here&quot;</span><br></pre></td></tr></table></figure><p>您可以将 Alchemy 视为区块链的 AWS EC2。它是一个节点提供者。它通过为我们提供节点来帮助我们与区块链连接，以便我们可以读取和写入区块链。Alchemy 帮助我们将合约部署到 rinkeby。</p><ul><li>现在我们将安装<code>dotenv</code>包以便能够导入 env 文件并在我们的配置中使用它。在您的终端中，执行这些命令。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install dotenv</span><br></pre></td></tr></table></figure><ul><li>现在打开 hardhat.config.js 文件，我们将在<code>rinkeby</code>此处添加网络，以便我们可以将合约部署到 rinkeby。<code>hardhat.config.js</code> 用下面给出的行替换文件中的所有行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;@nomicfoundation/hardhat-toolbox&quot;);</span><br><span class="line">require(&quot;dotenv&quot;).config(&#123; path: &quot;.env&quot; &#125;);</span><br><span class="line"></span><br><span class="line">const ALCHEMY_API_KEY_URL = process.env.ALCHEMY_API_KEY_URL;</span><br><span class="line">const RINKEBY_PRIVATE_KEY = process.env.RINKEBY_PRIVATE_KEY;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  solidity: &quot;0.8.9&quot;,</span><br><span class="line">  networks: &#123;</span><br><span class="line">    rinkeby: &#123;</span><br><span class="line">      url: ALCHEMY_API_KEY_URL,</span><br><span class="line">      accounts: [RINKEBY_PRIVATE_KEY],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>要在您的终端类型中部署：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx hardhat run scripts/deploy.js --network rinkeby</span><br></pre></td></tr></table></figure></li><li>将打印在终端上的 NFT 合约地址保存在记事本中，您将需要它。</li></ul><h2 id="在-Etherscan-上验证"><a href="#在-Etherscan-上验证" class="headerlink" title="在 Etherscan 上验证"></a>在 Etherscan 上验证</h2><ul><li>转到<a href="https://rinkeby.etherscan.io/">Rinkeby Etherscan</a>并搜索打印的地址。</li><li>如果 <code>address</code>在 etherscan 上打开，你已经部署了你的第一个 NFT 🎉</li><li>通过单击交易哈希转到交易详细信息，检查是否有令牌转移到您的地址</li></ul>]]></content>
    
    
    <summary type="html">在以太坊上部署 NFT 项目</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level8:加密货币(ERC20)</title>
    <link href="http://blog.julysong.com/2022/08/04/web3-freshman-level8/"/>
    <id>http://blog.julysong.com/2022/08/04/web3-freshman-level8/</id>
    <published>2022-08-04T05:59:51.000Z</published>
    <updated>2025-02-20T06:39:02.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/cryptocurrency-tutorial">https://www.learnweb3.io/tracks/freshman/cryptocurrency-tutorial</a></p><p>翻译: JulySong</p></blockquote><hr><p>我们将在本教程中使用<a href="https://metamask.io/">Metamask</a>和<a href="https://remix.ethereum.org/">Remix IDE</a>。</p><h2 id="喜欢视频？"><a href="#喜欢视频？" class="headerlink" title="喜欢视频？"></a>喜欢视频？</h2><p>如果您想从视频中学习，我们的 YouTube 上有本教程的录音。单击下面的屏幕截图观看视频，或继续阅读教程！<br><a href="https://www.youtube.com/watch?v=5yM5bojHbmQ"><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/1.png?raw=true"></a></p><h2 id="什么是-ERC-20？"><a href="#什么是-ERC-20？" class="headerlink" title="什么是 ERC-20？"></a>什么是 ERC-20？</h2><p><code>ERC</code>代表<code>Ethereum Request for Comment</code>。从本质上讲，它们是已获得社区批准的标准，用于传达某些用例的技术要求和规范。</p><p><code>ERC-20</code>特别是一个标准，它概述了可替代代币的技术规范。</p><blockquote><p>可替代令牌是令牌的所有“部分”都相同的令牌。将 1 ETH 换成不同的 1 ETH 不会改变任何东西。你还有 1 ETH。因此，ETH 是一种可替代的代币。所有法定货币也是可替代的。</p></blockquote><blockquote><p>NFT 是不可替代代币的示例（稍后会详细介绍），其中每个代币都不同于不同的代币。</p></blockquote><p>以太坊上的大多数代币都符合 <code>ERC-20</code> 规范。遵循类似标准 <code>ERC-20</code>允许使用 <code>ERC-20</code> 令牌的应用程序开发人员轻松支持所有 <code>ERC-20</code> 令牌，而无需单独为它们编写专门的代码。</p><p>例如，像 <a href="https://uniswap.org/">Uniswap</a> 这样的去中心化交易所允许您将任何代币换成任何其他代币。这是可能的，因为几乎所有代币都遵循 <code>ERC-20</code> 标准，因此 Uniswap 可以编写适用于所有遵循标准的代币的代码。</p><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li>确保您已下载并安装<a href="https://metamask.io/">Metamask</a>。</li><li>选择 <code>Rinkeby Testnet</code> 要使用的网络</li><li>通过以下任一水龙头在 Rinkeby 上请求一些测试网以太：<ul><li><a href="https://faucet.metamask.io/">Metamask 水龙头</a></li><li><a href="https://faucets.chain.link/rinkeby">Chainlink 水龙头</a></li><li><a href="https://faucet.paradigm.xyz/">Paradigm 水龙头</a></li></ul></li></ul><p>一旦你设置了所有这些，让我们开始吧！</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>我们正在使用 <a href="https://remix.ethereum.org/">Remix IDE</a> 来编写智能合约。</p><p>在 Remix 中，创建一个新的合约文件，我将其命名为 <code>LW3Token.sol</code>- 你可以随意命名！</p><p>在合约中，编写如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract LW3Token is ERC20 &#123;</span><br><span class="line">    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) &#123;</span><br><span class="line">        _mint(msg.sender, 10 * 10 ** 18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们逐行分解并了解发生了什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br></pre></td></tr></table></figure><p>此行指定要使用的 Solidity 的编译器版本。^0.8.0 表示任何大于 0.8.0. 通常，您会希望使用最新的 Solidity 编译器版本，因为新版本通常意味着新功能或优化。</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol&quot;;</span><br></pre></td></tr></table></figure><p>此行从<a href="https://openzeppelin.com/">OpenZeppelin</a> (OZ)导入<code>ERC-20</code>令牌标准。OZ 是一家以太坊安全公司。除其他外，OZ 为流行的智能合约标准开发参考合约，这些标准经过全面测试且安全。每当实施需要符合标准的智能合约时，请尝试找到 OZ 参考实施，而不是从头开始重写整个标准。</p><p><code>ERC-20</code>如果您愿意，可以通过以下链接查看标准合约的实施- <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol</a></p><blockquote><p>注意：在大二课程中，我们将更深入地研究 ERC-20 标准合同，以了解该合同中发生的一切。</p></blockquote><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract LW3Token is ERC20 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在我们的 Solidity 文件中指定了一个名为 LW3Token 的新合约。此外，它表示该合同<code>is</code>是<code>ERC20</code>. <code>ERC20</code>这里指的是我们从 OpenZeppelin 导入的标准合约。</p><p>本质上，我们正在扩展<code>ERC20</code>从 OpenZeppelin 导入的标准合约。所以内置的所有功能和逻辑<code>ERC20</code>都可供我们使用，我们可以在其上添加自己的自定义逻辑。</p><p>如果您熟悉面向对象的编程原则，您可以将其视为扩展另一个类的类。</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) &#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个位有一些你以前可能没有见过的奇怪的语法。<code>Kotlin</code>实际上有一些类似的语法，但我离题了。</p><p>本质上，我们创建了在首次部署智能合约时调用的<code>constructor</code>。在构造函数中，我们需要来自用户的两个参数 - _name 和 _symbol，它们指定我们加密货币的名称和符号。例如名称 &#x3D; 以太坊，符号 &#x3D; ETH。</p><p>之后发生的事情更有趣。在指定构造函数后，我们立即调用<code>ERC20(_name, _symbol)</code>.</p><p>我们从 OpenZeppelin 导入的<code>ERC20</code>合约有自己的构造函数，它需要<code>name</code>和<code>symbol</code>参数。由于我们正在扩展 ERC20 合约，因此我们需要在部署 ERC20 合约时初始化 ERC20 合约。所以，作为我们构造函数的一部分，我们还需要调用<code>ERC20</code>合约上的构造函数。</p><p>因此，我们为我们的合约提供<code>_name</code>和<code>_symbol</code>变量，我们立即将其传递给<code>ERC20</code>构造函数，从而初始化<code>ERC20</code>智能合约。</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_mint(msg.sender, 10 * 10 ** 18);</span><br></pre></td></tr></table></figure><p>_mint 是 ERC20 标准合约内部的一个函数，也就是说它只能被合约本身调用。外部用户不能调用该函数。</p><p>由于您作为开发人员希望在部署此合约时收到一些代币，因此我们调用该<code>_mint</code>函数将一些代币铸造到<code>msg.sender</code>.</p><p><code>_mint</code>接受两个参数 - 铸造地址和铸造代币数量</p><p>msg.sender 是一个由以太坊虚拟机注入的全局变量，也就是进行此次交易的地址。由于您将是部署此合约的人，因此您的地址将在 msg.sender 中。</p><p><code>10 * 10 ** 18</code>指定您希望将 10 个完整令牌铸造到您的地址。</p><hr><blockquote><p>注意：您可能想知道为什么我们不只写 10 金额，而不是 10 ** 18（实际上是 10 ^ 18）。</p></blockquote><p>本质上，Solidity 不支持浮点数——即小数。此外，由于 ERC20 代币处理货币，使用浮点数是一个坏主意。</p><p>例如，考虑使用<code>(1/3) * 3</code>支持浮点数的语言进行的简单计算。你认为这会带来什么回报？</p><p>如果你认为它会返回 1，那你就错了。</p><p>由于浮点计算的不准确性，由于计算机不能表示无限数量的数字，因此<code>(1/3) * 3</code>实际上会产生类似<code>0.999999999</code>.</p><p>因此，在表示金融货币时，由于计算错误，不使用小数。作为替代方案，我们将每种货币表示为相对于该货币的最小不可分割部分的数量。例如，1 美元表示为 100 美分，因为在处理美元时，您的收益不能低于 1 美分。在那个编号系统中，1 美分只是 1，而不是 0.01。0.33 美元表示为 33，而不是 (1&#x2F;3)。</p><p><code>ERC20</code>默认情况下，令牌使用 18 位小数。所以 1 full<code>LW3Token</code>在这种情况下，实际上表示为<code>10 ^ 18</code>。因此，要获得 10 个完整<code>LW3Tokens</code>的，我们使用<code>10 * 10 ** 18</code>.</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>通过按保存（在 Windows 上为 CTRL + S，在 Mac 上为 Command + S）或转到<code>Compiler</code>Remix 中的选项卡，选择<code>LW3Token.sol</code>并点击来编译您的合约<code>Compile</code>。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/2.png?raw=true"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>转到 Remix 中的<code>Deployer</code>选项卡。</p><p>选择<code>Injected Web3</code>环境（确保您在 Rinkeby 测试网络上），然后连接您的 Metamask 钱包。</p><p>选择 LW3Token.sol 合约，并为构造函数参数 _name 和 _symbol 输入值。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/3.png?raw=true"><br>单击<code>Transact</code>并批准来自 Metamask 的交易以部署您的合约！</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/4.png?raw=true"><br>部署后，合同应显示在该<code>Deployed Contracts</code>部分下。点击<code>Copy Address</code>按钮复制合约地址。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/5.png?raw=true"><br>转到<a href="https://rinkeby.etherscan.io/">Rinkeby Etherscan</a>并搜索你的合约地址，你应该在那里看到它！</p><p>截取它并在 Discord 上分享以炫耀您新创建的令牌：D</p><h2 id="在-Metamask-中查看令牌"><a href="#在-Metamask-中查看令牌" class="headerlink" title="在 Metamask 中查看令牌"></a>在 Metamask 中查看令牌</h2><p>您可能会注意到，即使您将代币铸造到您的地址，它们也不会出现在 Metamask 中。</p><p>这是因为 Metamask 无法检测随机的 ERC20 代币余额（因为实际上有数十万个）。他们有一个最知名的 ERC20 代币列表，可以自动显示，但除此之外，对于您自己的代币，您通常需要告诉 Metamask 手动将其添加到您的钱包中。</p><p>为此：</p><ul><li>复制你的合约地址</li><li>打开 Metamask 并单击选项<code>Import Tokens</code>卡<code>Assets</code></li><li><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/6.png?raw=true"></li><li>输入你的代币合约地址，它应该会自动检测名称和小数位数</li><li>点击添加，您将在 Metamask 中看到您的余额！</li><li><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level8/7.png?raw=true"></li></ul><p>在 Discord 中分享屏幕截图！</p><p>恭喜！您已经成功部署并铸造了您自己的 ERC20 代币！从这里开始向上！</p>]]></content>
    
    
    <summary type="html">在这个循序渐进的教程中，您将学习如何在以太坊上创建和部署 ERC-20 代币。</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level7:使用Ethers.js创建以太坊Dapp</title>
    <link href="http://blog.julysong.com/2022/08/04/web3-freshman-level7/"/>
    <id>http://blog.julysong.com/2022/08/04/web3-freshman-level7/</id>
    <published>2022-08-04T03:07:46.000Z</published>
    <updated>2025-02-20T06:39:02.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/dapp-tutorial">https://www.learnweb3.io/tracks/freshman/dapp-tutorial</a></p><p>翻译: JulySong</p></blockquote><hr><h2 id="（来自BlockDevsUnited-BasicFrontEndTutorial）"><a href="#（来自BlockDevsUnited-BasicFrontEndTutorial）" class="headerlink" title="（来自BlockDevsUnited&#x2F;BasicFrontEndTutorial）"></a>（来自<a href="https://github.com/BlockDevsUnited/BasicFrontEndTutorial">BlockDevsUnited&#x2F;BasicFrontEndTutorial</a>）</h2><p>这是一个关于如何创建前端、部署 Solidity 智能合约并将它们连接在一起的分步教程。我们将使用<a href="https://metamask.io/">Metamask</a>、<a href="https://remix.ethereum.org/">Remix IDE</a>和<a href="https://github.com/ethers-io/ethers.js/">Ethers.js</a>。</p><p>在本教程结束时，您将能够创建一个简单的 HTML 前端，其中包含可以与智能合约功能交互的按钮。本教程分 3 个阶段进行</p><ul><li>创建一个基本的 HTML 网页</li><li>创建一个基本的 Solidity 智能合约</li><li>使用 Ethers.js 将网页与智能合约连接起来。</li></ul><h2 id="喜欢视频"><a href="#喜欢视频" class="headerlink" title="喜欢视频?"></a>喜欢视频?</h2><p>如果您想从视频中学习，我们的 YouTube 上有本教程的录音。单击下面的屏幕截图观看视频，或继续阅读教程！<br><a href="https://www.youtube.com/watch?v=aqxAWLi6UMA"><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level7/1.png?raw=true"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="1-下载并安装-MetaMask"><a href="#1-下载并安装-MetaMask" class="headerlink" title="1. 下载并安装 MetaMask"></a>1. 下载并安装 <a href="https://metamask.io/">MetaMask</a></h3><ul><li><p>从未使用过 Metamask？观看<a href="https://youtu.be/wlm4QcA8c4Q?t=66">此解释器视频</a></p><p>对我们来说重要的是：<code>1:06 to 4:14</code></p></li><li><p>单击顶部的以太坊主网。切换到 Ropsten Tesnet 并在您的 Metamask 钱包上获取帐户公共地址的副本。</p></li></ul><h3 id="2-从加载到-Metamask-钱包中的水龙头请求一些-Ropsten-Tesnet-以太币。"><a href="#2-从加载到-Metamask-钱包中的水龙头请求一些-Ropsten-Tesnet-以太币。" class="headerlink" title="2. 从加载到 Metamask 钱包中的水龙头请求一些 Ropsten Tesnet 以太币。"></a>2. 从加载到 Metamask 钱包中的水龙头请求一些 Ropsten Tesnet 以太币。</h3><ul><li><p><a href="https://faucet.egorfine.com/">请求资金的水龙头链接</a></p></li><li><p><a href="https://blog.b9lab.com/when-we-first-built-our-faucet-we-deployed-it-on-the-morden-testnet-70bfbf4e317e">解释水龙头及其使用方法的博客</a></p></li></ul><h3 id="3-安装-http-服务器。使用任何你喜欢的，但我们建议-lite-server-初学者："><a href="#3-安装-http-服务器。使用任何你喜欢的，但我们建议-lite-server-初学者：" class="headerlink" title="3. 安装 http 服务器。使用任何你喜欢的，但我们建议 lite-server 初学者："></a>3. 安装 http 服务器。使用任何你喜欢的，但我们建议 lite-server 初学者：</h3><ul><li><p>安装 Node.js（<a href="https://nodejs.org/en/download/">下载和说明</a>）</p></li><li><p>安装 lite-server（在终端&#x2F;命令提示符下使用 NPM）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g lite-server #install lite-server globally</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="创建并提供一个简单的网页"><a href="#创建并提供一个简单的网页" class="headerlink" title="创建并提供一个简单的网页"></a>创建并提供一个简单的网页</h2><p>第一步是创建一个基本的 HTML 页面。</p><ol><li>使用在终端中创建一个新文件夹（目录）<code>mkdir &lt;directory name&gt;</code></li><li>在代码编辑器（例如 Atom 或 Visual Studio Code）中，打开文件夹</li><li>创建一个名为的新文件 <code>index.html</code></li><li>打开 index.html</li><li>创建 HTML 样板</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;title&gt;My First dApp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们将创建一个简单地向区块链读取和写入值的应用程序。我们将需要一个标签、一个输入和按钮。</p><ol start="6"><li>在 body 标签内，添加一些文本、标签和输入。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;This is my dApp!&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Here we can set or get the mood:&lt;/p&gt;</span><br><span class="line">    &lt;label for=&quot;mood&quot;&gt;Input Mood:&lt;/label&gt; &lt;br /&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;mood&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>在 div 标签内添加一些按钮。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;getMood()&quot;&gt;Get Mood&lt;/button&gt;</span><br><span class="line">&lt;button onclick=&quot;setMood()&quot;&gt;Set Mood&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>可选：在<head>标签内，添加一些样式使其看起来更好看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  body &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    font-family: Arial, Helvetica, sans-serif;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  div &#123;</span><br><span class="line">    width: 20%;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  button &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    margin: 10px 0px 5px 0px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ol start="8"><li>通过终端&#x2F;命令提示符从其中包含的目录中提供网页<code>index.html</code>并运行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lite-server</span><br></pre></td></tr></table></figure><ol start="9"><li><p>在浏览器中访问<a href="http://127.0.0.1:3000/[%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%82%A8%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%81](http://127.0.0.1:3000/)">http://127.0.0.1:3000/[以查看您的页面！](http://127.0.0.1:3000/)</a></p></li><li><p>您的前端现已完成！</p></li></ol><hr><h2 id="创建一个基本的智能合约"><a href="#创建一个基本的智能合约" class="headerlink" title="创建一个基本的智能合约"></a>创建一个基本的智能合约</h2><p>现在是时候创建一个 Solidity 智能合约了。</p><ol><li><p>您可以使用任何您喜欢的编辑器来制作合同。对于本教程，我们推荐在线 IDE <a href="https://remix.ethereum.org/">Remix</a></p><ul><li>以前从未使用过 Remix？看<a href="https://www.youtube.com/watch?v=pdJttvcAV1c">此视频</a></li></ul></li><li><p>去 <a href="https://remix.ethereum.org/">Remix</a></p></li><li><p>查看“Solidity Compiler”和“Deploy and Run Transactions”选项卡。如果它们不存在，请在插件管理器中启用它们</p></li><li><p>在 remix 中创建一个新的 Solidity 文件，命名为 <code>mood.sol</code></p></li><li><p>编写合约</p><ul><li>指定 solidity 版本并添加 license</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.1;</span><br></pre></td></tr></table></figure><ul><li>定义合约</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">contract MoodDiary&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在合约内部创建一个名为 mood 的变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string mood;</span><br></pre></td></tr></table></figure><ul><li>接下来，创建读取和写入函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//create a function that writes a mood to the smart contract</span><br><span class="line"> function setMood(string memory _mood) public&#123;</span><br><span class="line">     mood = _mood;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //create a function the reads the mood from the smart contract</span><br><span class="line"> function getMood() public view returns(string memory)&#123;</span><br><span class="line">     return mood;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>就是这样！您的代码应如下<a href="https://github.com/LearnWeb3DAO/BasicFrontEndTutorial/blob/master/contracts/mood.sol">所示</a></li></ul></li><li><p>在 Ropsten 测试网上部署合约。</p><ul><li>确保您的 Metamask 已连接到 Ropsten 测试网。</li><li>确保选择正确的编译器版本以匹配 solidity 合约。（在编译选项卡中）</li><li>使用“Solidity Compiler”选项卡编译代码。请注意，加载编译器可能需要一些时间</li><li>在“部署和运行事务”选项卡下部署合约</li><li>在 Deployed Contracts 部分下，您可以在 Remix Run 选项卡上测试您的函数，以确保您的合约按预期工作！</li></ul></li></ol><p>一定要在<code>Injected Web3</code>环境下通过 Remix 部署到 Ropsten 上，并在 Metamask 中确认部署事务</p><p>制作一个新的临时文件来保存：</p><ul><li>部署的合约地址<ul><li>通过 remix 的 Run 选项卡中已部署的合同下拉列表旁边的复制按钮复制它</li></ul></li><li>合约 ABI（<a href="https://solidity.readthedocs.io/en/develop/abi-spec.html">那是什么？</a>）<ul><li>通过 remix 的 Compile 选项卡中的合同下的复制按钮将其复制（也在详细信息中）</li></ul></li></ul><h2 id="将您的网页连接到您的智能合约"><a href="#将您的网页连接到您的智能合约" class="headerlink" title="将您的网页连接到您的智能合约"></a>将您的网页连接到您的智能合约</h2><p>回到您的本地文本编辑器中<code>index.html</code>，将以下代码添加到您的 html 页面：</p><ol><li><code>index.html</code>在一组新的脚本标签中将 Ethers.js 源代码导入您的页面：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  src=&quot;https://cdn.ethers.io/lib/ethers-5.2.umd.min.js&quot;</span><br><span class="line">  type=&quot;application/javascript&quot;</span><br><span class="line">&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  ////////////////////</span><br><span class="line">  //ADD YOUR CODE HERE</span><br><span class="line">  ////////////////////</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 script 标签中，导入合约 ABI（<a href="https://solidity.readthedocs.io/en/develop/abi-spec.html">那是什么？</a>）并在我们的供应商区块链上指定合约地址：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const MoodContractAddress = &quot;&lt;contract address&gt;&quot;;</span><br><span class="line">const MoodContractABI = &lt;contract ABI&gt;</span><br><span class="line">let MoodContract;</span><br><span class="line">let signer;</span><br></pre></td></tr></table></figure><p>对于合约 ABI，我们希望专门导航到<a href="https://docs.soliditylang.org/en/develop/abi-spec.html#json">JSON 部分</a>。我们需要以 JSON 格式描述我们的智能合约。</p><p>由于我们有两个方法，这应该从一个数组开始，有 2 个对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const MoodContractABI = [&#123;&#125;, &#123;&#125;]</span><br></pre></td></tr></table></figure><p>在上面的页面中，每个对象都应具有以下字段：<code>constant</code>、<code>inputs</code>、<code>name</code>、<code>outputs</code>、<code>payable</code>、<code>stateMutability</code>和<code>type</code></p><p>对于<code>setMood</code>，我们在下面描述每个字段：</p><ul><li>名称：<code>setMood</code>，不言自明</li><li>类型：<code>function</code>，不言自明</li><li>输出：应该是<code>[]</code>因为这不返回任何东西</li><li>stateMutability：这是<code>nonpayable</code>因为这个函数不接受 Ether</li><li>输入：这是函数的输入数组。数组中的每个对象都应该有<code>internalType</code>,<code>name</code>和<code>type</code>, 这些分别是<code>string</code>,<code>_mood</code>和<code>string</code></li></ul><p>对于<code>getMood</code>，我们在下面描述每个字段：</p><ul><li>名称：<code>getMood</code>，不言自明</li><li>类型：<code>function</code>，不言自明</li><li>输出：这与中的类型相同 <code>inputs</code>。<code>setMood</code> 对于 <code>internalType</code>,<code>name</code> 和 <code>type</code>, 这应该分别是 <code>string</code>, <code>&quot;&quot;</code>, 和 <code>string</code></li><li>stateMutability：这是 <code>view</code> 因为这是一个视图函数</li><li>输入：这没有参数，所以这应该是[]</li></ul><p>您的最终结果应如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const MoodContractABI = [</span><br><span class="line">&#123;</span><br><span class="line">&quot;inputs&quot;: [],</span><br><span class="line">&quot;name&quot;: &quot;getMood&quot;,</span><br><span class="line">&quot;outputs&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;internalType&quot;: &quot;string&quot;,</span><br><span class="line">&quot;name&quot;: &quot;&quot;,</span><br><span class="line">&quot;type&quot;: &quot;string&quot;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;stateMutability&quot;: &quot;view&quot;,</span><br><span class="line">&quot;type&quot;: &quot;function&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;inputs&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;internalType&quot;: &quot;string&quot;,</span><br><span class="line">&quot;name&quot;: &quot;_mood&quot;,</span><br><span class="line">&quot;type&quot;: &quot;string&quot;</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;name&quot;: &quot;setMood&quot;,</span><br><span class="line">&quot;outputs&quot;: [],</span><br><span class="line">&quot;stateMutability&quot;: &quot;nonpayable&quot;,</span><br><span class="line">&quot;type&quot;: &quot;function&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来，定义一个 ethers 提供者。在我们的例子中，它是 Ropsten：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const provider = new ethers.providers.Web3Provider(window.ethereum, &quot;ropsten&quot;);</span><br></pre></td></tr></table></figure><ol start="4"><li>请求访问用户的钱包并将签名者连接到您的元掩码帐户（我们使用<code>[0]</code>默认），并使用您的合约地址、ABI 和签名者定义合约对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">provider.send(&quot;eth_requestAccounts&quot;, []).then(() =&gt; &#123;</span><br><span class="line">  provider.listAccounts().then((accounts) =&gt; &#123;</span><br><span class="line">    signer = provider.getSigner(accounts[0]);</span><br><span class="line">    MoodContract = new ethers.Contract(</span><br><span class="line">      MoodContractAddress,</span><br><span class="line">      MoodContractABI,</span><br><span class="line">      signer</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li>创建异步函数来调用你的智能合约函数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function getMood() &#123;</span><br><span class="line">  const getMoodPromise = MoodContract.getMood();</span><br><span class="line">  const Mood = await getMoodPromise;</span><br><span class="line">  console.log(Mood);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function setMood() &#123;</span><br><span class="line">  const mood = document.getElementById(&quot;mood&quot;).value;</span><br><span class="line">  const setMoodPromise = MoodContract.setMood(mood);</span><br><span class="line">  await setMoodPromise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>将您的功能连接到您的 html 按钮</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;getMood()&quot;&gt;Get Mood&lt;/button&gt;</span><br><span class="line">&lt;button onclick=&quot;setMood()&quot;&gt;Set Mood&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="测试你的例子"><a href="#测试你的例子" class="headerlink" title="测试你的例子!"></a>测试你的例子!</h2><ol><li>你的网络服务器启动了吗？在浏览器中访问<a href="http://127.0.0.1:3000/[%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%82%A8%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%81](http://127.0.0.1:3000/)">http://127.0.0.1:3000/[以查看您的页面！](http://127.0.0.1:3000/)</a></li><li>通过 Metamask 测试您的功能并根据需要批准交易。注意块时间约为 15 秒……所以请稍等一下以读取区块链的状态</li><li><a href="https://ropsten.etherscan.io/">通过 https://ropsten.etherscan.io/</a>查看您的合约和交易信息</li><li>在浏览器中打开控制台 (<code>Ctrl + Shift + i</code>) 以查看按下这些按钮时发生的奇迹</li></ol><h2 id="完毕！"><a href="#完毕！" class="headerlink" title="完毕！"></a>完毕！</h2><p>庆祝！您刚刚制作了一个网页，该网页与互联网上真实的以太坊测试网进行了交互！这不是很多人可以说他们做过的事情！</p><h2 id="如果您在本教程中遇到问题，可以试用提供的示例应用程序。"><a href="#如果您在本教程中遇到问题，可以试用提供的示例应用程序。" class="headerlink" title="如果您在本教程中遇到问题，可以试用提供的示例应用程序。"></a>如果您在本教程中遇到问题，可以试用提供的示例应用程序。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/LearnWeb3DAO/BasicFrontEndTutorial.git</span><br><span class="line">cd BasicFrontEndTutorial</span><br><span class="line">lite-server</span><br></pre></td></tr></table></figure><p>尝试使用以下信息与我们在 Roptsen 测试网上发布的现有合约进行交互：</p><ul><li>我们在此<a href="https://ropsten.etherscan.io/tx/0x8da093fdc4ae3e1b469dfff97b414a9800c9fdd8c1c897b6b746faf43aa3b7f8">交易</a>MoodDiary 中创建了一个合约实例</li><li>这是合同（<a href="https://ropsten.etherscan.io/address/0xc5afd2d92750612a9619db2282d9037c58fc22cb">在 etherscan 上</a>）<ul><li>我们还向<a href="https://ropsten.etherscan.io/address/0xc5afd2d92750612a9619db2282d9037c58fc22cb#code">ropsten.etherscan.io</a>验证了我们的源代码，作为您验证合约到底是什么的附加措施，并且 ABI 也可供全世界使用！</li></ul></li><li>ABI 也在<a href="https://github.com/LearnWeb3DAO/BasicFrontEndTutorial/blob/master/Mood_ABI.json">这个文件中</a></li></ul><p>这说明了一个重点：您也可以构建一个 dApp ，而无需自己编写以太坊合约！如果你想使用已经在以太坊上编写的现有合约，你可以！</p>]]></content>
    
    
    <summary type="html">web3系列之新手篇</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level6:Solidity</title>
    <link href="http://blog.julysong.com/2022/08/03/web3-freshman-level6/"/>
    <id>http://blog.julysong.com/2022/08/03/web3-freshman-level6/</id>
    <published>2022-08-03T11:19:39.000Z</published>
    <updated>2025-02-20T06:39:02.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/solidity">https://www.learnweb3.io/tracks/freshman/solidity</a></p><p>翻译: JulySong</p></blockquote><h2 id="什么是-Solidity"><a href="#什么是-Solidity" class="headerlink" title="什么是 Solidity?"></a>什么是 Solidity?</h2><ul><li>Solidity 是一种面向对象的高级语言，用于实现智能合约。它旨在针对<a href="https://coinmarketcap.com/alexandria/glossary/ethereum-virtual-machine-evm">以太坊虚拟机（EVM）</a></li><li>它是静态类型的，支持继承、库和复杂的用户声明类型等特性。</li></ul><h2 id="构建-Solidity"><a href="#构建-Solidity" class="headerlink" title="构建 Solidity"></a>构建 Solidity</h2><h3 id="初始化智能合约"><a href="#初始化智能合约" class="headerlink" title="初始化智能合约"></a>初始化智能合约</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Define the compiler version you would be using</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">// Start by creating a contract named HelloWorld</span><br><span class="line">contract HelloWorld &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>Solidity 中有 3 种类型的变量</p><ul><li>Local<ul><li>在函数内部声明并且不存储在区块链上</li></ul></li><li>State<ul><li>在维护智能合约状态的函数之外声明</li><li>存储在区块链上</li></ul></li><li>Global<ul><li>提供有关区块链的信息。它们在运行时由以太坊虚拟机注入。</li><li>包括交易发送者、区块时间戳、区块哈希等。</li><li><a href="https://docs.soliditylang.org/en/v0.8.9/units-and-global-variables.html">全局变量示例</a></li></ul></li></ul><p>变量的范围是由它们的声明位置声明的，而不是它们的值。将局部变量的值设置为全局变量不会使其成为全局变量，因为它仍然只能在其范围内访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 定义您将使用的编译器版本</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">// 首先创建一个名为 Variables的合约</span><br><span class="line">contract Variables &#123;</span><br><span class="line">    /*</span><br><span class="line">        ******** State 变量 **********</span><br><span class="line">    */</span><br><span class="line">    /*</span><br><span class="line">        使用uint代表无符号整数, 表示不同大小的非负整数可用. 例如:</span><br><span class="line">            - uint8   范围 从 0 到 2 ** 8 - 1</span><br><span class="line">            - uint256 范围 从 0 到 2 ** 256 - 1</span><br><span class="line">        `public` 表示该变量可以被合约内部访问，也可以被外部世界读取</span><br><span class="line">    */</span><br><span class="line">    uint8 public u8 = 10;</span><br><span class="line">    uint public u256 = 600;</span><br><span class="line">    uint public u = 1230; // uint is an alias for uint256</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        该int类型允许为负数. 例如:</span><br><span class="line">            - int256 ranges from -2 ** 255 to 2 ** 255 - 1</span><br><span class="line">    */</span><br><span class="line">    int public i = -123; // int 相当于 int256</span><br><span class="line"></span><br><span class="line">    // address 代表了一个以太坊地址</span><br><span class="line">    address public addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;</span><br><span class="line"></span><br><span class="line">    // bool 代表了 boolean类型</span><br><span class="line">    bool public defaultBoo1 = false;</span><br><span class="line"></span><br><span class="line">    // 默认值</span><br><span class="line">    // 在Solidity中未赋值的变量有一个默认值</span><br><span class="line">    bool public defaultBoo2; // false</span><br><span class="line">    uint public defaultUint; // 0</span><br><span class="line">    int public defaultInt; // 0</span><br><span class="line">    address public defaultAddr; // 0x0000000000000000000000000000000000000000</span><br><span class="line"></span><br><span class="line">    function doSomething() public &#123;</span><br><span class="line">        /*</span><br><span class="line">        ******** Local 变量 **********</span><br><span class="line">        */</span><br><span class="line">        uint ui = 456;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        ******** Global 变量 **********</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            block.timestamp 告诉我们当前块的时间戳是什么</span><br><span class="line">            msg.sender 告诉我们哪个地址调用了 doSomething 函数</span><br><span class="line">        */</span><br><span class="line">        uint timestamp = block.timestamp; // 当前区块时间戳</span><br><span class="line">        address sender = msg.sender; // 调用者地址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数、循环和-If-Else"><a href="#函数、循环和-If-Else" class="headerlink" title="函数、循环和 If&#x2F;Else"></a>函数、循环和 If&#x2F;Else</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 声明您将使用的编译器版本</span><br><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">// 首先创建一个合同叫Conditions</span><br><span class="line">contract Conditions &#123;</span><br><span class="line">    // 声明一个State变量来存储数字</span><br><span class="line">    uint public num;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        函数的名称是 set.</span><br><span class="line">        需要在使用uint和num设置state变量。</span><br><span class="line">        该方法声明为public 类型表示它也可以从内部被称为合同和外部。</span><br><span class="line">    */</span><br><span class="line">    function set(uint _num) public &#123;</span><br><span class="line">        num = _num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        函数的名称是 get。</span><br><span class="line">        该方法的返回值为数字</span><br><span class="line">        该方法声明为view 类型表示函数不改变任何变量的状态。</span><br><span class="line">        在solidity中view函数不消耗汽油.</span><br><span class="line">    */</span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        函数名是 foo。</span><br><span class="line">        该方法需要一个unit参数, 并且返回一个unit参数。</span><br><span class="line">        该方法通过if/else来比较入参x的大小</span><br><span class="line">    */</span><br><span class="line">    function foo(uint x) public returns (uint) &#123;</span><br><span class="line">        if (x &lt; 10) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (x &lt; 20) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">        函数的名称是循环。</span><br><span class="line">        它运行一个循环直到 10</span><br><span class="line">    */</span><br><span class="line">    function loop() public &#123;</span><br><span class="line">        // for 循环</span><br><span class="line">        for (uint i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                // 用continue跳到下一个迭代</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 5) &#123;</span><br><span class="line">                // 用break跳出循环</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组、字符串"><a href="#数组、字符串" class="headerlink" title="数组、字符串"></a>数组、字符串</h3><p>数组可以具有编译时固定大小或动态大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.10;</span><br><span class="line"></span><br><span class="line">contract Array &#123;</span><br><span class="line"></span><br><span class="line">    // 声明一个public字符串变量</span><br><span class="line">    string public greet = &quot;Hello World!&quot;;</span><br><span class="line">    // 初始化数组的几种方式</span><br><span class="line">    // 这里初始化的数组被认为是存储在区块链上的状态变量</span><br><span class="line">    // 以下就是存储变量</span><br><span class="line">    uint[] public arr;</span><br><span class="line">    uint[] public arr2 = [1, 2, 3];</span><br><span class="line">    // 固定大小的数组,初始化所有元素为0</span><br><span class="line">    uint[10] public myFixedSizeArr;</span><br><span class="line">    /*</span><br><span class="line">        函数的名称是 get</span><br><span class="line">        它获取存储在数组索引中的元素的值</span><br><span class="line">    */</span><br><span class="line">    function get(uint i) public view returns (uint) &#123;</span><br><span class="line">        return arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     Solidity 可以返回整个数组。</span><br><span class="line">     这个函数被调用并返回一个 uint[] 内存。</span><br><span class="line">     内存 - 该值仅存储在内存中，而不是在区块链上，</span><br><span class="line">              它仅在函数执行期间存在</span><br><span class="line"></span><br><span class="line">     Memory变量和Storage变量可以被认为类似于 RAM 与硬盘。</span><br><span class="line">     Memory变量在函数执行期间暂时存在，而Storage变量</span><br><span class="line">     在合约生命周期内跨函数调用保持不变。</span><br><span class="line">     这里数组仅在函数执行期间需要，因此被声明为Memory变量</span><br><span class="line">    */</span><br><span class="line">    function getArr(uint[] memory _arr) public view returns (uint[] memory) &#123;</span><br><span class="line">        return _arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     /*</span><br><span class="line">        此函数返回字符串内存。</span><br><span class="line">        添加 memory 关键字的原因是因为 string 在内部作为数组工作</span><br><span class="line">        这里字符串仅在函数执行时才需要。</span><br><span class="line">    */</span><br><span class="line">    function foo() public returns (string memory) &#123;</span><br><span class="line">        return &quot;C&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function doStuff(uint i) public &#123;</span><br><span class="line">        // 追加到数组</span><br><span class="line">        // 这将使数组长度增加 1.</span><br><span class="line">        arr.push(i);</span><br><span class="line">        // 从数组中删除最后一个元素</span><br><span class="line">        // 这将使数组长度减少 1</span><br><span class="line">        arr.pop();</span><br><span class="line">        // 获取数组的长度</span><br><span class="line">        uint length = arr.length;</span><br><span class="line">        // 删除不会改变数组长度。</span><br><span class="line">        // 它将 index 处的值重置为其默认值，</span><br><span class="line">        // 在这种情况下，它将 arr2 中索引 1 处的值重置为 0</span><br><span class="line">        uint index = 1;</span><br><span class="line">        delete arr2[index];</span><br><span class="line">        // 在内存中创建数组，只能创建固定大小</span><br><span class="line">        uint[] memory a = new uint[](5);</span><br><span class="line">        // 在内存中创建字符串</span><br><span class="line">        string memory hi = &quot;hi&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://solidity-by-example.org/">Solidity 实例</a></li></ul><h2 id="其他学习资源"><a href="#其他学习资源" class="headerlink" title="其他学习资源"></a>其他学习资源</h2><ul><li><a href="https://cryptozombies.io/">Cryptozombies</a></li><li><a href="https://solidity-by-example.org/">Solidity 实例</a></li><li><a href="https://docs.soliditylang.org/en/v0.8.10/">Solidity 文档</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 Solidity 在哪个虚拟机上运行？</p><p>A: JVM</p><p>B: EVM</p><p>C: KVM</p></li><li><p>🤔 Solidity 中的 State 变量是什么？</p><p>A: 它们在函数内声明，不存储在区块链上</p><p>B: 它们在函数外部声明并存储在区块链上</p><p>C: 他们提供有关区块链的信息</p></li><li><p>🤔 uint 代表什么？</p><p>A: 大学情报</p><p>B: 普遍审讯</p><p>C: 通用整数</p><p>D: 无符号整数</p></li><li><p>🤔 uint8 的范围是多少？</p><p>A: 0 到 2 ** 256 - 1</p><p>B: 0 到 2 ** 16 - 1</p><p>C: 0 到 2 ** 8 - 1</p></li><li><p>🤔 bool 变量的默认值是多少？</p><p>A: True</p><p>B: False</p></li><li><p>🤔 地址变量的默认值是多少？</p><p>A: 0x0936f87C98E8009f8C4fff9E3994b295761C30ad</p><p>B: 0x00000000000000000000000000000000000000000</p><p>C: 0xD9cd57AaECf5813FC41E26CFd55f67Fd72112b75</p></li><li><p>🤔 函数声明中 public 关键字的意义是什么？</p><p>A: 函数只能被其他智能合约函数内部调用</p><p>B: 函数只能在外部调用</p><p>C: 它可以从合约内部调用，也可以从外部调用。</p></li><li><p>🤔 函数声明中 view 关键字的意义是什么？</p><p>A: 这意味着该函数可以改变合约的状态</p><p>B: 函数不能改变合约的状态</p><p>C: 它让任意方法不消耗汽油</p></li><li><p>🤔 从函数返回无符号整数数组的正确函数声明是什么？</p><p>A: function getArr(uint[] memory _arr) public view returns (uint[] memory)</p><p>B: function getArr(uint[] memory _arr) public view returns (uint[])</p><p>C: function getArr(uint[] memory _arr) public view returns ([]uint)</p></li><li><p>🤔 如何在 Solidity 中获取数组的长度？</p><p>A: len(arr)</p><p>A: arr.length</p><p>A: arr.size()</p></li><li><p>🤔 如何在 Solidity 中向数组中添加元素？</p><p>A: arr.push(i)</p><p>A: arr.add(i)</p><p>A: arr.back(i)</p></li><li><p>🤔 msg.sender 是什么？</p><p>A: 调用者地址</p><p>B: 一个函数名</p><p>C: 给你发短信的人的电话号码</p></li><li><p>🤔 block.coinbase 的值是什么？</p><p>A: Coinbase 交易所地址</p><p>B: 开采该区块的矿工的地址</p><p>C: 当前区块的 gas 价格</p></li></ol><blockquote><p>参考答案:</p><ol><li>B</li><li>B</li><li>D</li><li>C</li><li>B</li><li>B</li><li>C</li><li>B</li><li>A</li><li>B</li><li>A</li><li>A</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">在本模块中，您将了解什么是 Solidity 以及该语言的基本语法。</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level5:Remix IDE</title>
    <link href="http://blog.julysong.com/2022/08/03/web3-freshman-level5/"/>
    <id>http://blog.julysong.com/2022/08/03/web3-freshman-level5/</id>
    <published>2022-08-03T09:43:52.000Z</published>
    <updated>2025-02-20T06:39:02.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/remix-ide">https://www.learnweb3.io/tracks/freshman/remix-ide</a></p><p>翻译: JulySong</p></blockquote><p>Remix 是用于以太坊开发的开源、Web 和桌面集成开发环境 (IDE)。它是开始在以太坊上构建的最简单的开发工具，并且拥有大量插件来扩展其体验。</p><p>Remix 可帮助您直接在浏览器中编写 Solidity 代码，并提供用于测试、调试和将智能合约部署到区块链的工具。</p><p>你可以在<a href="https://remix.ethereum.org/%E8%AE%BF%E9%97%AE">https://remix.ethereum.org/访问</a> Remix</p><h2 id="导航-Remix"><a href="#导航-Remix" class="headerlink" title="导航 Remix"></a>导航 Remix</h2><p>当您第一次打开 Remix 时，您会看到这样的屏幕。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/2.png?raw=true"><br><code>File Explorer</code>在左侧边栏中，您可以在、<code>Solidity Compiler</code>、<code>Deployer</code>和<code>Extensions</code>面板之间切换。</p><p>在底部，有一个输出面板，显示编译、部署和函数调用的输出。</p><p>中间是您将编辑代码的地方。目前它显示 IDE 的主屏幕，但是一旦我们打开一个文件，它将成为代码编辑器。</p><h2 id="Remix-工作流程"><a href="#Remix-工作流程" class="headerlink" title="Remix 工作流程"></a>Remix 工作流程</h2><p>在侧边栏中，如果您查看<code>contracts</code>文件夹下方 - Remix 附带 3 个基本智能合约，以帮助人们学习 Solidity。让我们来看看<code>1_Storage.sol</code>。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/3.png?raw=true"><br>我们现在可以看到代码编辑器了。</p><p>在文件资源管理器中，我们还可以看到创建新文件或目录、上传本地文件或从 Github 导入文件的选项。</p><p>为了编译我们的合约，我们切换到 <code>Solidity Compiler</code> 选项卡，我们将在侧边栏中看到类似的内容。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/4.png?raw=true"><br>在这里，我们可以选择<code>Compiler Version</code>我们想要的、我们使用的智能合约编程语言（大多数情况下你只会使用 Solidity），以及一些进一步的配置选项。</p><p>注意：Remix 中列出的另一种编程语言 <code>Yul</code> 是低级语言。它用于中间编译，比 Solidity 更接近硬件。99% 的时间你不会在 Yul 中编码。<br>在此处阅读有关 Yul 的更多信息 - <a href="https://docs.soliditylang.org/en/v0.8.9/yul.html">https://docs.soliditylang.org/en/v0.8.9/yul.html</a></p><p>单击 <code>Compile 1_Storage.sol</code> 将编译合约并使其准备好部署。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/5.png?raw=true"><br>转到<code>Deployment</code>选项卡，我们将在侧边栏中看到类似的内容。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/6.png?raw=true"><br>这里首先要注意的是<code>Environment</code>. Remix 附带一个<code>Javascript VM</code>- 这是浏览器中以太坊虚拟机 (EVM) 的模拟器。只要您的合约不依赖于部署到真实以太坊网络的另一个合约，这便可以快速测试和调试您的智能合约。谢天谢地，我们的存储合约没有，所以我们可以在 Javascript VM 中测试它。</p><p>要部署到实际网络，我们将希望将我们更改<code>Environment</code>为那里列出的其他选项之一（稍后会详细介绍）。</p><p>除了<code>Javascript VM</code>，Remix 还创建了一组虚假账户，所有账户都装有 100 ETH，以供测试。</p><p>从下拉列表中选择<code>1_Storage.sol</code>合约，然后单击<code>Deploy</code>以部署合约。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/7.png?raw=true"><br>部署合约后，您将在该<code>Deployed Contracts</code>部分下看到它 - 您现在可以在其中调用智能合约上的函数。</p><p>调用该<code>retrieve</code>函数将返回一个<code>0</code>right now 值，这是 Solidity 中整数的默认值。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/8.png?raw=true"><br>此外，我们将在“输出”面板中看到一些关于<code>Storage.retrieve</code>我们的函数调用的日志。</p><p>现在，让我们尝试<code>store</code>使用 number 调用该值<code>5</code>。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/9.png?raw=true"><br>同样，我们在输出面板中看到一些关于调用的日志<code>Storage.store</code>。现在，如果我们再次尝试<code>retrieve</code>，输出将是<code>5</code>.</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level5/10.png?raw=true"></p><p>注意- 我们所做的这些函数调用&#x2F;交易都没有打开您的数字钱包 (Metamask)。这是因为我们<code>Javascript VM</code>目前正在测试，而那只是一个使用假账户的模拟器。部署到真实网络（测试网或主网）时，需要通过您的数字钱包确认和签署交易。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>要了解有关 Remix 的更多信息，我们建议：</p><ul><li>浏览 <a href="https://remix-ide.readthedocs.io/en/latest/">Remix IDE Docs 上的文档</a></li><li>使用 Remix 附带的默认智能合约来处理工作流程</li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 IDE 代表什么？</p><p>A: 集成开发环境</p><p>B: 智能不和谐环境</p><p>C: 有意的开发人员体验</p><p>D: 恼怒的开发者愤怒</p></li><li><p>🤔 Remix 可以写什么?</p><p>A: Solidity 合约</p><p>B: 可靠性测试</p><p>C: Javascript 脚本</p><p>D: 上述所有的</p></li><li><p>🤔 以下哪一项不是 Remix 中的面板？</p><p>A: 文件管理器</p><p>B: 版本控制历史</p><p>C: Solidity 编译器</p></li><li><p>🤔 Remix 不支持以下哪个环境？</p><p>A: Javascript 虚拟机</p><p>B: Rinkeby 测试网</p><p>C: Solana 测试网</p><p>D: 以太坊主网</p></li><li><p>🤔 你可以用 Solidity 以外的语言在 Remix 上写代码吗？</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Remix 不支持以下哪些功能？</p><p>A: 与已部署的智能合约交互</p><p>B: 从 Github 存储库导入代码</p><p>C: 提供免费的测试网以太</p></li><li><p>🤔 Remix 允许您与未部署的合约进行交互</p><p>A: 真的</p><p>B: 错误的</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>D</li><li>B</li><li>C</li><li>A</li><li>C</li><li>A</li></ol></blockquote>]]></content>
    
    
    <summary type="html">web3系列之新手篇</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level4:加密钱包</title>
    <link href="http://blog.julysong.com/2022/08/03/web3-freshman-level4/"/>
    <id>http://blog.julysong.com/2022/08/03/web3-freshman-level4/</id>
    <published>2022-08-03T09:25:49.000Z</published>
    <updated>2025-02-20T06:39:02.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/crypto-wallets">https://www.learnweb3.io/tracks/freshman/crypto-wallets</a></p><p>翻译: JulySong</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>要完全理解加密钱包，我们必须了解一些关于区块链的概念，这将有助于我们理解钱包如何帮助我们。让我们开始吧。</p><h2 id="什么是地址？🤨"><a href="#什么是地址？🤨" class="headerlink" title="什么是地址？🤨"></a>什么是地址？🤨</h2><p>地址是使用加密技术生成的一串文本，用于表示您在区块链上的帐户。这个地址可以与其他人公开共享，这样做是完全安全的。您可以从您的钱包地址发送和接收资金。基本上，地址是您在区块链上的唯一标识符，代表您的“帐户”。<br>以太坊地址的一个例子是：<code>0x01573Df433484fCBe6325a0c6E051Dc62Ab107D1</code>.</p><h2 id="什么是私钥？🔐"><a href="#什么是私钥？🔐" class="headerlink" title="什么是私钥？🔐"></a>什么是私钥？🔐</h2><p>私钥是地址的对应物。每个地址都有一个关联的私钥。顾名思义，这意味着保密，不与任何人共享。</p><p>你可以把它想象成一个密码，一个非常强大的密码，它包含一堆字母和数字，可以让你证明对你的地址的所有权。任何拥有私钥的人都可以从您的地址进行交易，即从您的地址向他们的地址汇款。</p><p>私钥看起来像这样：<code>E9873D79C6D87DC0FB6A5778633389F4453213303DA61F20BD67FC233AA33262</code></p><p>如果您将您的地址视为您帐户的用户名，那么私钥就是它的密码。因此，分享您的地址是可以的，但永远不要分享您的私钥，否则有人可能会窃取您的资金——然后就无能为力了。</p><p>注意：由于区块链是去中心化的，因此没有“忘记密码”选项。如果您丢失了您的私钥，您将无法访问您的帐户。同样，如果有人窃取了您的私钥并窃取了您的资金，您将无能为力。保持此私钥的安全非常重要。</p><p>对于开发人员，我们经常使用私钥作为代码库的一部分来执行某些交易，例如将我们自己的智能合约部署到以太坊网络。当您仍在学习时，我们强烈建议您完全使用单独的帐户进行开发，而不是用于存储任何类型的资金。不幸的是，初学者开发人员经常使用他们拥有资金的同一个帐户，并且不小心公开共享他们的代码库 - 黑客可以在代码库中看到您的私钥并最终窃取资金。请把它当作一个谨慎的故事。</p><h2 id="什么是助记词？👮‍♀️"><a href="#什么是助记词？👮‍♀️" class="headerlink" title="什么是助记词？👮‍♀️"></a>什么是助记词？👮‍♀️</h2><p>助记词就像一个主密码 - 密码的密码！</p><p>想想密码管理器，比如 Lastpass 或 1Password。这些应用程序在其中安全地存储您用于其他应用程序的用户名和密码，并且它们本身也有密码。因此，如果有人破解了您的密码管理器，他们还可以访问存储在其中的所有帐户。</p><p>加密钱包有点像密码管理器，您可以在其中管理多个区块链帐户。如果私钥是单个帐户的密码，则种子短语有点像该钱包的主密码。</p><p>当你创建一个新的加密钱包时，你会看到一个助记词，你应该绝对安全地存储和备份。您从该钱包中生成的任何新帐户都将链接到助记词。那一个助记词将始终生成相同的帐户，每个帐户具有相同的私钥和地址。</p><p>因此，例如，如果您创建了一个钱包，然后在其中创建了 5 个帐户，则您的助记词管理所有 5 个帐户。如果您想切换到新钱包，您可以单独导入 5 个钱包 - 通过使用它们各自的私钥 -或者只是使用助记词导入，它会重新生成相同的 5 个帐户。</p><p>种子短语的一个例子是：<code>dove lumber quote board young robust kit invite plastic regular skull history</code></p><h2 id="那么什么是加密钱包呢？😛"><a href="#那么什么是加密钱包呢？😛" class="headerlink" title="那么什么是加密钱包呢？😛"></a>那么什么是加密钱包呢？😛</h2><p>加密钱包是您账户的管理者，主要是他们的私钥。它们还允许您与去中心化应用程序交互，并允许通过钱包连接到 dApp，充当构建在区块链上的所有应用程序的单点登录。</p><p>在 LearnWeb3 上，您也可以进入仪表板并连接您的加密钱包（在您设置之后），这将让我们知道您的地址是什么，这样我们就可以在您从我们的轨道毕业时向您发送一些生病的 NFT！</p><h2 id="设置钱包-🎉"><a href="#设置钱包-🎉" class="headerlink" title="设置钱包 🎉"></a>设置钱包 🎉</h2><p>对于以太坊，有许多可用的钱包选项。Metamask 或 Coinbase 钱包是最容易上手且对开发人员最友好的。</p><p>两者都是以太坊加密钱包，可以作为浏览器扩展或移动应用程序安装。您可以在下面找到下载链接。我们建议下载其中任何一个并进行设置，然后再继续进行跟踪。</p><ul><li><a href="https://metamask.io/download.html">下载 Download Metamask</a></li><li><a href="https://www.coinbase.com/wallet">下载 Coinbase Wallet</a></li></ul><p>其他替代品包括 Trust Wallet、Atomic Wallet、Rainbow Wallet、Frame.sh 等。</p><ul><li><a href="https://trustwallet.com/">Trust Wallet</a></li><li><a href="https://atomicwallet.io/">Atomic Wallet</a></li><li><a href="https://rainbow.me/">Rainbow Wallet</a></li><li><a href="https://frame.sh/">Frame.sh</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 什么是地址？</p><p>A: 一个地址代表一种加密货币</p><p>B: 地址代表您在区块链上的帐户</p><p>C: 地址代表您的加密货币余额</p></li><li><p>🤔 以下哪一项是以太坊地址？</p><p>A: bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh</p><p>B: 0x71C7656EC7ab88b098defB751B7401B5f6d8976F</p><p>C: @LearnWeb3DAO</p></li><li><p>🤔 什么是私钥？</p><p>A: 私钥就像您帐户的强密码</p><p>B: 私钥是地址的另一个名称</p><p>C: 私钥是指加密钱包</p></li><li><p>🤔 你应该如何处理你的私钥？</p><p>A: 您应该与所有人共享您的私钥</p><p>B: 您应该只与您的朋友和家人共享您的私钥</p><p>C: 你永远不应该分享你的私钥</p></li><li><p>🤔 什么是助记词？</p><p>A: 种子短语就像您地址的密码</p><p>B: 种子短语就像您的加密钱包的主密码</p><p>C: 种子短语就像私钥的密码</p></li><li><p>🤔 什么是助记词的例子？</p><p>A: correct horse battery staple</p><p>B: Y123456789</p><p>C: jealous expect hundred young unlock disagree major siren surge acoustic machine catalog</p></li><li><p>🤔 什么是加密钱包？</p><p>A: 加密钱包管理你的助记词</p><p>B: 加密钱包管理与您的地址关联的私钥</p><p>C: 加密钱包管理您的加密余额</p></li><li><p>🤔 MetaMask 是什么？</p><p>A: 以太坊钱包(An Ethereum wallet)</p><p>B: 比特币钱包(A Bitcoin wallet)</p><p>C: 索拉纳钱包(A Solana wallet)</p></li><li><p>🤔 你下载钱包并设置了吗？</p><p>A: 是的</p><p>B: 没有</p></li></ol><blockquote><p>参考答案:</p><ol><li>B</li><li>B</li><li>A</li><li>C</li><li>B</li><li>C</li><li>B</li><li>A</li><li>A</li></ol></blockquote>]]></content>
    
    
    <summary type="html">在本模块中，您将了解什么是加密钱包以及如何下载。🤔</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>前端开发要点</title>
    <link href="http://blog.julysong.com/2022/08/02/frontend-development-the-essentials/"/>
    <id>http://blog.julysong.com/2022/08/02/frontend-development-the-essentials/</id>
    <published>2022-08-02T11:15:57.000Z</published>
    <updated>2025-02-20T06:39:02.259Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://betterprogramming.pub/frontend-development-the-essentials-1c1290b43590">https://betterprogramming.pub/frontend-development-the-essentials-1c1290b43590</a></p><p>翻译: JulySong</p></blockquote><p><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/1.jpeg?raw=true"></p><div style="text-align: center;d"><a style="color: gray"href="https://en.wikipedia.org/wiki/Tomb_of_Hafez">Tomb of Hafez, Shiraz</a></div>这篇文章适合任何想在没有编程背景的情况下开始前端开发的人。最终目标是帮助爱好者了解软件开发的松散世界，并使他们能够在这个拥挤的生态系统中找到自己的方式。结果是开始学习过程的路线图。<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>前段时间，有几个朋友问我如何成为一名前端开发人员。我向他们介绍了要走的路，还给了他们一些关键字，例如 Git、HTML、CSS 等。但后来我发现，对于没有任何编程背景的人来说，进入这个行业是有障碍的。他们应该首先熟悉生态系统。</p><p>他们很快就会被大量的教育材料所淹没，对于每个关键字，谷歌都会返回大量的结果。就像你想买你的第一辆车，有很多不同的车型，有不同的选择，价格相同。如果你没有得到任何关于你的目标规格的建议，你很快就会感到困惑，要么选择坏的，要么离开商店。</p><p>在本文中，我将尝试为您提供软件开发生态系统的视角和概览。我还将为您提供一些有用的关键字，以及一些指向教育材料和博客文章的链接。最后，你会带着一张学习路线图离开。</p><p>在开始之前，我想再次提一下，前端开发是开发人员最拥挤的社区之一，所以不要害怕大量奇怪的名称、库和技术。目标是使您免于被人群淹没，并为您提供可以帮助您找到方向的知识。</p><h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><p>让我们从网页由什么组成的问题开始。</p><p>把网站想象成一本有一些页面的书，一本高级的书，其中每一页都由图像、文本、视频、音频和一个名为链接的特殊元素组成。在网页上，我们可以将所有这些元素放在一起，将它们设置为带有字体和颜色的书页，还可以将它们放在不同的布局中。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/2.jpeg?raw=true"><br>正是链接使网页不同于一本书。链接的作用是帮助您以非顺序的顺序在页面之间导航。链接可以将访问者带到网站的任意页面。您可以根据每页上的链接在页面之间跳转，甚至可以跳转到其他书籍的页面。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/3.png?raw=true"></p><h3 id="网页元素"><a href="#网页元素" class="headerlink" title="网页元素"></a>网页元素</h3><p>你在网页上看到的几乎所有其他东西都是这些基本元素的组合：</p><ul><li>文本</li><li>图片</li><li>声音的</li><li>视频</li><li>链接（导航元素）</li></ul><p>网站的目的是提供信息以及特定于业务的用户体验。</p><h2 id="网络开发技术"><a href="#网络开发技术" class="headerlink" title="网络开发技术"></a>网络开发技术</h2><p>支持 Web 开发的主要技术有以下三种：</p><ul><li>HTML（超文本标记语言）</li><li>CSS（级联样式表）</li><li>JavaScript（浏览器理解的动态编程语言）</li></ul><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><blockquote><p>“超文本标记语言 (HTML) 是设计用于在<a href="https://en.wikipedia.org/wiki/Web_browser">Web 浏览器</a>中显示的文档的标准<a href="https://en.wikipedia.org/wiki/Markup_language">标记语言</a>。它可以通过<a href="https://en.wikipedia.org/wiki/Cascading_Style_Sheets">级联样式表</a>(CSS) 等技术和 JavaScript 等<a href="https://en.wikipedia.org/wiki/JavaScript">脚本语言</a>来辅助。” —<a href="https://en.wikipedia.org/wiki/HTML">维基百科</a></p></blockquote><p><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/4.png?raw=true"><br>HTML 是一种标记语言。这意味着您通过称为标签的 HTML 元素创建页面内容。每个标签都有自己的特定属性和行为。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/5.png?raw=true"></p><p>这是<a href="https://www.w3schools.com/TAGS/default.ASP">HTML 标记</a>列表。</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>HTML 用于构建页面内容。在 CSS 的帮助下，可以根据布局、颜色、字体和样式设置页面样式。使用 CSS，我们可以制作可维护和可扩展的样式。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript 是一种浏览器可以理解的动态脚本语言。在 JavaScript 的帮助下，网页可以进行交互，例如当您单击按钮时，您可以向用户显示特定数据。想想你以前见过的所有登录按钮。JavaScript 支持它们以启用它们的功能和交互。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/6.png?raw=true"></p><div style="text-align: center;color: gray">图片来源: <a style="color: gray" href="https://www.cleanpng.com/png-responsive-web-design-web-development-html-javascr-1046856/preview.html">CleanPng</a></div><p>所以现在我们知道，借助三种技术，我们可以构建网页。我们将在进一步的步骤中研究如何做到这一点。</p><h2 id="编写代码使其生效的过程"><a href="#编写代码使其生效的过程" class="headerlink" title="编写代码使其生效的过程"></a>编写代码使其生效的过程</h2><p>在这一点上，我将为您提供整个软件开发过程的广泛而简单的视角，从您开始编写第一行代码到您将 Web 应用程序上线。这个过程在任何软件开发平台上都有些相同，包括 Android 和 iOS。</p><p>为您提供此概述的目的是表明软件开发过程不仅仅是编写代码。在其中，您会听到很多与流程其他部分相关的奇怪和新词。<br><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/7.png?raw=true"></p><div style="text-align: center;color: gray">软件开发过程非常重要</div><p>记住这个事实：整个过程是迭代的。每次将应用程序上线时，您都应该监控用户或利益相关者的请求和反馈，然后计划更改。</p><h3 id="源代码控制"><a href="#源代码控制" class="headerlink" title="源代码控制"></a>源代码控制</h3><p>如果您在团队中工作，甚至单独工作，您需要了解的一件事就是源代码控制。软件开发发生在迭代中，并且在每次迭代中，您都会添加新功能或修复错误。为了跟踪源代码的变化，我们需要一种机制。源代码控制工具是跟踪代码库更改并允许团队中代码库协作的方法。</p><p><a href="https://git-scm.com/">Git</a> 是开发人员最常用的源代码控制工具之一。正如<a href="https://books.google.ca/books?id=nYjhDwAAQBAJ&pg=PT101&lpg=PT101&dq=s+goals+include+speed,+data+integrity,+and+support+for+distributed,+non-linear+workflows.&source=bl&ots=8iV6gquLBx&sig=ACfU3U2E-OmUydwQiMArK3yDjR7M8-Zj-w&hl=en&sa=X&ved=2ahUKEwib0JWuqM_pAhWRVN8KHYeYBoAQ6AEwAHoECAkQAQ#v=onepage&q=s%20goals%20include%20speed%2C%20data%20integrity%2C%20and%20support%20for%20distributed%2C%20non-linear%20workflows.&f=false">Web Development Glossary</a>中所述，“Git 是一个分布式版本控制系统，用于在开发过程中跟踪源代码的更改。它是为协调程序员之间的工作而设计的，但它可用于跟踪任何文件集的更改。它的目标包括速度、数据完整性以及对分布式非线性工作流的支持。”<br><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/8.png?raw=true"></p><div style="text-align: center;color: gray">源代码控制机制</div><h2 id="软件开发生态系统"><a href="#软件开发生态系统" class="headerlink" title="软件开发生态系统"></a>软件开发生态系统</h2><p>这是一个有趣的话题。我们将了解一些重要的平台，这些平台可以帮助您与他人交流、学习和分享您的挑战。技术行业，尤其 ​​ 是软件行业的沟通对所有参与者都至关重要。科技行业发展迅速，其中一个原因是该行业的沟通和知识共享精神。</p><p>在本主题中，我将为您提供一些指向技术知识中心的链接，尤其是那些用于前端开发的知识中心。</p><h3 id="W3-学校"><a href="#W3-学校" class="headerlink" title="W3 学校"></a><a href="https://www.w3schools.com/">W3 学校</a></h3><p>W3Schools 是开始学习 JavaScript、HTML 和 CSS 的良好参考之一。它还涵盖了一些其他主题，例如 React 和 SQL。这是开始使用命名主题的好地方。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a><a href="https://stackoverflow.com/">Stack Overflow</a></h3><p>如果您对特定案例有疑问，答案在 Stack Overflow 中。这是一个网站，任何在开发过程中遇到他们不知道如何解决的问题的开发人员都会首先查看问题和答案。这是一个知识共享和交流平台。我想其他行业的人会羡慕我们拥有这个了不起的平台。</p><h3 id="npmJS-组织"><a href="#npmJS-组织" class="headerlink" title="npmJS 组织"></a><a href="https://www.npmjs.com/">npmJS 组织</a></h3><p>如果您正在寻找任何 JavaScript 或 TypeScript 库或工具，这里就是将它们保存为存储库的地方。将来，您将经常使用该网站。这是一个参考和存储库，您将使用它来构建自己的解决方案并避免重新发明轮子。</p><p>软件开发通过将大问题分解成小问题、使用小块解决方案（代码）并将它们组合起来解决更大的问题来解决问题。</p><h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://github.com/">GitHub</a></h3><p>有几个云源控制平台，但这个很特别，因为您可以找到大量流行的开源项目和库。此外，几乎所有的 npm 包源代码都托管在 GitHub 上。将 GitHub 视为共享代码的平台。</p><h3 id="Udemy"><a href="#Udemy" class="headerlink" title="Udemy"></a><a href="https://www.udemy.com/">Udemy</a></h3><p>Udemy 是科技行业的教育平台之一，可帮助开发人员提高技能。在这个平台上有大量与前端开发相关的不同课程，您可以浏览和选择。<br>还有其他平台，如 <a href="https://www.coursera.org/">Coursera</a>、<a href="https://www.edx.org/">Edx</a>、<a href="https://www.lynda.com/">Lynda</a> 等，您可以在其中找到与前端开发相关的课程。</p><h3 id="hackerrank"><a href="#hackerrank" class="headerlink" title="hackerrank"></a><a href="https://www.hackerrank.com/">hackerrank</a></h3><p>该平台通过引入您需要找到答案的挑战来帮助您提高编程技能。这些挑战帮助您学习编程、算法和数据结构。这是一个非常有用的平台，可以提高您的编程技能。</p><h2 id="前端开发技术"><a href="#前端开发技术" class="headerlink" title="前端开发技术"></a>前端开发技术</h2><p>在这里，我们将看看用于前端开发的不同技术。实际上，最重要的是要学习 JavaScript。其余的是可以简化开发的库或框架，但最终，它们是基于 JavaScript（浏览器可以理解的语言）的库和框架。</p><p>请记住，JavaScript 是最重要的。学习 JavaScript 极大地帮助您更好地阅读和理解库和框架。</p><p>你应该学习的 JavaScript 概念：</p><ul><li>词汇结构</li><li>表达式</li><li>类型</li><li>变量</li><li>功能</li><li>this</li><li>箭头函数</li><li>循环</li><li>范围</li><li>数组</li><li>模板文字</li><li>分号</li><li>严格模式</li><li>ECMAScript 6、2016、2017</li><li><a href="https://www.w3schools.com/js/js_json_intro.asp">JSON</a></li><li><a href="https://nodejs.org/en/">Node</a>。它是在服务器或任何独立于浏览器的机器上<a href="https://www.w3schools.com/nodejs/default.asp">运行 JavaScript 的环境</a>。</li><li>HTTP 请求和响应模型和 REST API 概念。</li><li>使用 JavaScript 处理文件和机器资源</li><li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await">async&#x2F;await</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">module</a></li><li><a href="https://en.wikipedia.org/wiki/Npm_(software)">npm</a></li></ul><p>接下来要学习的是熟悉 <a href="https://www.w3schools.com/html/">HTML</a> 和 <a href="https://css-tricks.com/">CSS3</a>。HTML 和 CSS 组合是您工作的视觉方面。尝试了解它们的结构和要领。其余的是不同类型的实现，如果您了解 HTML 和 CSS，对您来说会很容易。</p><p>学习 <a href="https://jquery.com/">JQuery</a>，这是一个 JavaScript 库，旨在简化 HTML DOM 树的遍历和操作，以及事件处理、CSS 动画和 Ajax。它是免费的开源软件。</p><h3 id="现代前端库和框架"><a href="#现代前端库和框架" class="headerlink" title="现代前端库和框架"></a>现代前端库和框架</h3><p>注意：以下定义取自维基百科和其他在线资源。</p><ul><li><a href="https://angularjs.org/">AngularJs</a> “AngularJS 是一个基于 JavaScript 的开源前端 Web 框架，主要由 Google 和个人社区维护。它是最流行的前端开发框架之一。” —<a href="https://en.wikipedia.org/wiki/AngularJS">维基百科</a>。</li><li><a href="https://reactjs.org/">ReactJs</a> “ React 是一个用于构建用户界面的 JavaScript 库。它由 Facebook 和个人开发者社区维护。” —<a href="https://en.wikipedia.org/wiki/React_(web_framework)">维基百科</a>。<br>ReactJs 也是最受欢迎的之一，周围有一个很大的社区。<br><a href="https://vuejs.org/">VueJs</a> “Vue 是一个开源的 Model-View-ViewModel JavaScript 框架，用于构建用户界面和单页应用程序。它由 Evan You 创建，由他和来自 Netlify 和 Netguru 等不同公司的其他活跃核心团队成员维护。” —<a href="https://www.marsmedia.info/en/service/vuejs">火星媒体</a><br>首先，只关注一个。作为一名初级开发人员，你有很多工作机会——但我再次强调 JavaScript，因为它是你知识的核心结构。</li></ul><p>要找到一份初级 Web 开发人员的工作，首先，请访问 LinkedIn 等网站。搜索与前端开发相关的工作，看看最需要哪些关键字和库，然后去学习它们。</p><h2 id="如何选择合适的工具"><a href="#如何选择合适的工具" class="headerlink" title="如何选择合适的工具"></a>如何选择合适的工具</h2><p>您需要一些工具来编写、执行和调试代码。以下是我对基本工具的建议。（注：以下定义取自维基百科和其他在线资源。）</p><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a><a href="https://code.visualstudio.com/">VS Code</a></h3><p>“Visual Studio Code 是微软为 Windows、Linux 和 macOS 开发的源代码编辑器。它包括嵌入式 Git 和对调试、语法高亮显示、智能代码完成、片段和代码重构的支持。” —<a href="https://en.wikipedia.org/wiki/Visual_Studio_Code">维基百科</a>。</p><h3 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a><a href="https://ohmyz.sh/">ZSH</a></h3><p>“<a href="https://en.wikipedia.org/wiki/Command-line_interface">Z shell</a> 是一个 Unix shell 或 CLI，可以用作交互式登录 shell 和 shell 脚本的命令解释器。ZSH 支持插件并为您提供了许多有助于轻松使用 CLI 的功能”——<a href="https://en.wikipedia.org/wiki/Z_shell">维基百科</a>。</p><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><p>“Postman 是一个流行的 API 客户端，它使开发人员可以轻松地创建、共享、测试和记录 API。这是通过允许用户创建和保存简单和复杂的 HTTP&#x2F;s 请求以及读取他们的响应来完成的。” — <a href="https://dzone.com/articles/how-to-use-postman-to-manage-and-execute-your-apis">DZone</a>。</p><p>这些是必需品，但肯定有大量的浏览器插件和 VS Code 可以简化您的开发生活。</p><h2 id="计划和路线图"><a href="#计划和路线图" class="headerlink" title="计划和路线图"></a>计划和路线图</h2><p>为了实现一个目标，你应该有一个计划和一个路线图。在本节中，我将尝试为您提供成为前端开发人员的最低路线图。您可以在两个月或一年内完成路线图——这完全取决于您。你在这个职业发展上投入的时间是一个关键因素。</p><p>你可以通过开始 Udemy ReactJs 课程来学习前端开发，但是在求职面试中，你会遇到很多新的和未知的问题和关键词。我的目标是帮助你作为一名真正的开发人员从根本上学习前端开发。还要记住，要学习一些东西，你需要做一些事情，所以你需要从零开始编写代码。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/frontend-development-the-essentials/9.png?raw=true"></p><h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p>以下是每个主题的顶级课程和教程列表。那里有大量的内容，但这些都是好的开始。只需从每个主题中选择一两个即可。</p><h3 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML + CSS"></a>HTML + CSS</h3><ul><li><a href="https://www.youtube.com/user/DesignCourse">https://www.youtube.com/user/DesignCourse</a><blockquote><p>一个很棒的 youtube 频道，用于讨论和教授前端开发</p></blockquote></li><li><a href="https://www.udemy.com/course/web-design-for-beginners-real-world-coding-in-html-css/">https://www.udemy.com/course/web-design-for-beginners-real-world-coding-in-html-css/</a><blockquote><p>HTML 和 CSS 的好评初学者课程</p></blockquote></li><li><a href="https://egghead.io/playlists/css-fundamentals-238ce697">https://egghead.io/playlists/css-fundamentals-238ce697</a><blockquote><p>适合初学者的 CSS</p></blockquote></li><li><a href="https://www.coursera.org/specializations/web-design">https://www.coursera.org/specializations/web-design</a><blockquote><p>HTML 和 CSS 的另一门好课程</p></blockquote></li></ul><h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul><li><a href="https://www.udemy.com/course/javascript-basics-for-beginners/">https://www.udemy.com/course/javascript-basics-for-beginners/</a></li><li><a href="https://www.udemy.com/course/javascript-for-beginners-introduction-learn-fast-easy/">https://www.udemy.com/course/javascript-for-beginners-introduction-learn-fast-easy/</a></li><li><a href="https://www.udemy.com/course/modern-javascript/">https://www.udemy.com/course/modern-javascript/</a></li><li><a href="https://www.coursera.org/learn/javascript-jquery-json">https://www.coursera.org/learn/javascript-jquery-json</a></li><li><a href="https://www.edx.org/course/javascript-introduction">https://www.edx.org/course/javascript-introduction</a></li><li><a href="https://www.edx.org/course/programming-for-the-web-with-javascript">https://www.edx.org/course/programming-for-the-web-with-javascript</a></li></ul><h3 id="VS-Code-1"><a href="#VS-Code-1" class="headerlink" title="VS Code"></a>VS Code</h3><ul><li><a href="https://egghead.io/browse/tools/vscode">https://egghead.io/browse/tools/vscode</a><blockquote><p>这是您了解更多关于 IDE 和 VsCode 的好地方。</p></blockquote></li></ul><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul><li><a href="https://www.udemy.com/course/git-going-fast/">https://www.udemy.com/course/git-going-fast/</a></li><li><a href="https://gist.github.com/nicowilliams/a6e5c9131767364ce2f4b3996549748d">https://gist.github.com/nicowilliams/a6e5c9131767364ce2f4b3996549748d</a></li><li><a href="https://egghead.io/browse/tools/git">https://egghead.io/browse/tools/git</a></li><li><a href="https://www.udemy.com/course/git-complete/">https://www.udemy.com/course/git-complete/</a></li></ul><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><ul><li><a href="https://www.w3schools.com/nodejs/default.asp">https://www.w3schools.com/nodejs/default.asp</a></li><li><a href="https://nodejs.dev/learn/introduction-to-nodejs">https://nodejs.dev/learn/introduction-to-nodejs</a></li><li><a href="https://www.youtube.com/watch?v=TlB_eWDSMt4">https://www.youtube.com/watch?v=TlB_eWDSMt4</a></li><li><a href="https://www.youtube.com/user/programmingwithmosh">https://www.youtube.com/user/programmingwithmosh</a></li><li><a href="https://www.udemy.com/course/the-complete-nodejs-developer-course-2/">https://www.udemy.com/course/the-complete-nodejs-developer-course-2/</a></li></ul><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><ul><li><a href="https://www.udemy.com/course/understanding-npm/">https://www.udemy.com/course/understanding-npm/</a></li><li><a href="https://www.tutorialspoint.com/nodejs/nodejs_npm.htm">https://www.tutorialspoint.com/nodejs/nodejs_npm.htm</a></li><li><a href="https://www.w3schools.com/nodejs/nodejs_npm.asp">https://www.w3schools.com/nodejs/nodejs_npm.asp</a></li></ul><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><ul><li><a href="https://egghead.io/courses/understand-the-basics-of-http">https://egghead.io/courses/understand-the-basics-of-http</a></li></ul><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><ul><li><a href="https://reactjs.org/tutorial/tutorial.html">https://reactjs.org/tutorial/tutorial.html</a><blockquote><p>这是最好的起点。React 网站有一个很棒的简单教程来教授基础知识。</p></blockquote></li><li><a href="https://reactjs.org/community/courses.html">https://reactjs.org/community/courses.html</a><blockquote><p>然后看看这个。</p></blockquote></li><li><a href="https://www.w3schools.com/react/">https://www.w3schools.com/react/</a></li><li><a href="https://egghead.io/courses/the-beginner-s-guide-to-react">https://egghead.io/courses/the-beginner-s-guide-to-react</a></li></ul><h3 id="Chrome-开发者工具"><a href="#Chrome-开发者工具" class="headerlink" title="Chrome 开发者工具"></a>Chrome 开发者工具</h3><ul><li><a href="https://egghead.io/browse/tools/chrome-devtools">https://egghead.io/browse/tools/chrome-devtools</a></li></ul><h3 id="GitHub-1"><a href="#GitHub-1" class="headerlink" title="GitHub"></a>GitHub</h3><ul><li><a href="https://egghead.io/browse/platforms/github">https://egghead.io/browse/platforms/github</a></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>写这篇文章的动机是帮助没有编程背景的热心人学习软件开发，尤其是 Web 前端开发。这里讨论的内容是您在学习任何库或框架之前应该学习的基本知识。在选择任何高级教育材料之前，您需要非常了解 JavaScript + HTML + CSS。然后一切都变得容易多了，你会很快学会任何前端框架。</p><p>谢谢阅读！</p>]]></content>
    
    
    <summary type="html">在开始前端开发职业之前你应该知道的事情</summary>
    
    
    
    <category term="学习笔记" scheme="http://blog.julysong.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="http://blog.julysong.com/tags/JavaScript/"/>
    
    <category term="Html" scheme="http://blog.julysong.com/tags/Html/"/>
    
    <category term="CSS" scheme="http://blog.julysong.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level3:什么是ETH?</title>
    <link href="http://blog.julysong.com/2022/08/02/web3-freshman-level3/"/>
    <id>http://blog.julysong.com/2022/08/02/web3-freshman-level3/</id>
    <published>2022-08-02T09:58:10.000Z</published>
    <updated>2025-02-20T06:39:02.266Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/what-is-eth">https://www.learnweb3.io/tracks/freshman/what-is-eth</a></p><p>翻译: JulySong</p></blockquote><h2 id="一-理论"><a href="#一-理论" class="headerlink" title="一. 理论"></a>一. 理论</h2><h3 id="什么是以太坊"><a href="#什么是以太坊" class="headerlink" title="什么是以太坊"></a>什么是以太坊</h3><p>以太坊是一个支持智能合约的去中心化区块链。与比特币只支持比特币代币在网络上的转移不同，以太坊更通用。</p><p>开发人员可以构建 dApp 或去中心化应用程序，这些应用程序可以在以太坊虚拟机 (EVM) 上的以太坊网络上执行。因此，以太坊的全球状态不仅包括每个账户的余额，还包括每个 dApp 的状态。</p><p>dApp 使用以太坊的编程语言 Solidity 构建在以太坊上。您可以使用 Solidity 编写智能合约并将智能合约部署到以太坊网络。</p><p>它通过工作证明 (PoW) 在其网络中的所有计算机之间保持共识。在不久的将来，随着 Serenity 补丁，以太坊将转向权益证明 (PoS) 机制。</p><h3 id="以太坊基础"><a href="#以太坊基础" class="headerlink" title="以太坊基础"></a>以太坊基础</h3><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>以太坊最初是由年轻的程序员和比特币杂志的联合创始人 <a href="https://en.wikipedia.org/wiki/Vitalik_Buterin">Vitalik Buterin</a> 提出的。他是一个好奇的学生，即使在年轻的时候也是一个天才的程序员。他曾经在 2007-2010 年玩过魔兽世界，然而，当暴雪决定从他最喜欢的术士的虹吸生命技能中移除伤害组件时，Buterin 非常沮丧并彻底退出了游戏。</p><p>2011 年，他遇到了比特币，并对这个想法非常着迷。他想正式投稿，所以他开始写关于它的文章，以换取每篇文章的几个比特币。2011 年底，他与人共同创办了比特币杂志，并全职投身于加密领域。他环游世界寻找各种加密项目，并意识到可以通过将图灵完备的通用编程语言集成到区块链中来概括大多数这些项目的功能。</p><p>Buterin 试图说服其他项目的开发人员中的比特币核心开发人员，区块链技术可以产生比货币交易所更广泛的影响，而区块链需要一种通用的编程语言来配合它。然而，在被现有项目拒绝后，他决定自己做。他继续提出用图灵完备的编程语言（Solidity）开发一个新的区块链平台，这就是我们所知道的以太坊.</p><p>2014 年，该项目公开宣布，核心团队由 Vitalik Buterin、Mihai Alise、Anthony Di Iorio、Charles Hoskinson、Joe Lubin 和 Gavin Wood 组成。几个月后，该团队为 Ether 代币举行了首次代币发行 (ICO) 以资助开发。该团队筹集了超过 31,000 BTC，当时约为 1800 万美元。然后，他们成立了以太坊基金会，这是一家总部位于瑞士的非营利组织，其任务是尽早看到以太坊的开源开发。</p><h4 id="什么是以太币"><a href="#什么是以太币" class="headerlink" title="什么是以太币"></a>什么是以太币</h4><p>以太坊有一种本地货币，称为“以太币”或“Eth”。该代币需要为在以太坊网络上进行的交易支付交易费用。</p><h4 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h4><p>智能合约是小型计算机程序，无需中央协调器即可在以太坊网络上的所有计算机上复制和处理。智能合约允许您编写可以由计算机代码自动执行的合约。</p><p>以太坊的通用性允许在其之上构建任意数量的可能应用程序，这些应用程序都继承了在以太坊区块链上运行所带来的安全性和去中心化优势。</p><h4 id="ERC20-代币"><a href="#ERC20-代币" class="headerlink" title="ERC20 代币"></a>ERC20 代币</h4><p>除了以太币，人们还可以在以太坊上创建和使用自己的货币。最常见的货币形式是 ERC20 代币。ERC20 代币是符合特定标准的智能合约。开发人员可以超越标准，但在制作自己的代币时应满足最低要求。标准化允许数字钱包轻松支持所有类型的代币，而无需为创建的每个代币使用专门的代码。</p><h4 id="ERC721-和-ERC1155-代币"><a href="#ERC721-和-ERC1155-代币" class="headerlink" title="ERC721 和 ERC1155 代币"></a>ERC721 和 ERC1155 代币</h4><p>这些也称为 NFT。这两个标准类似于 ERC20，为创建 NFT 时应满足的要求提供了基准。它们也提供类似的好处，允许钱包和 NFT 市场立即与所有 NFT 集合兼容，因为它们都遵循这两个标准之一。</p><p>还有很多…</p><h3 id="必读"><a href="#必读" class="headerlink" title="必读"></a>必读</h3><ul><li><a href="https://bitsonblocks.net/2016/10/02/gentle-introduction-ethereum/">https://bitsonblocks.net/2016/10/02/gentle-introduction-ethereum/</a></li></ul><h3 id="推荐读物"><a href="#推荐读物" class="headerlink" title="推荐读物"></a>推荐读物</h3><ul><li><a href="https://ethereum.org/en/whitepaper/">https://ethereum.org/en/whitepaper/</a></li><li><a href="https://cointelegraph.com/explained/erc-20-tokens-explained">https://cointelegraph.com/explained/erc-20-tokens-explained</a></li><li><a href="https://www.youtube.com/watch?v=ZE2HxTmxfrI">https://www.youtube.com/watch?v=ZE2HxTmxfrI</a></li><li><a href="https://blockgeeks.com/guides/smart-contracts/">https://blockgeeks.com/guides/smart-contracts/</a></li><li><a href="https://www.investopedia.com/news/what-erc20-and-what-does-it-mean-ethereum/">https://www.investopedia.com/news/what-erc20-and-what-does-it-mean-ethereum/</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 智能合约如何执行?</p><p>A: 在以太坊服务器上</p><p>B: 在以太坊虚拟机 (EVM) 上</p><p>C: 杰夫贝索斯经营他们</p></li><li><p>🤔 以太坊目前使用哪种共识算法？</p><p>A: 工作证明(POW)</p><p>B: 权益证明(POS)</p><p>C: 权威证明(POA)</p></li><li><p>🤔 在 Serenity 补丁中……以太坊将转向权益证明</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 以太坊的原生货币是什么？</p><p>A: NEAR</p><p>B: MATIC</p><p>C: ETH</p><p>D: BTC</p></li><li><p>🤔 如果您在以太坊主网上编写智能合约……它将在以太坊主网上的所有计算机上复制和处理。</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 你可以在没有以太坊许可的情况下创建自己的 ERC-20 代币</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 哪个陈述最能描述工作量证明？</p><p>A: 允许拥有最多货币的矿工开采并将区块添加到区块链</p><p>B: 矿工们竞相解决计算难题。本次比赛的获胜者可以在区块链中添加一个区块。</p><p>C: 矿工计算 EVM 路由问题。第一个解决问题的矿工可以向区块链添加区块</p></li><li><p>🤔 谁的“出块时间”更短？</p><p>A: Bitcoin</p><p>B: Ethereum</p></li><li><p>🤔 谁的“块大小”更大？</p><p>A: Bitcoin</p><p>B: Ethereum</p></li></ol><blockquote><p>参考答案:</p><ol><li>B</li><li>A</li><li>A</li><li>C</li><li>A</li><li>A</li><li>B</li><li>B</li><li>A</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之新手篇</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level2:什么是Web3?</title>
    <link href="http://blog.julysong.com/2022/08/02/web3-freshman-level2/"/>
    <id>http://blog.julysong.com/2022/08/02/web3-freshman-level2/</id>
    <published>2022-08-02T09:33:53.000Z</published>
    <updated>2025-02-20T06:39:02.266Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/what-is-web3">https://www.learnweb3.io/tracks/freshman/what-is-web3</a></p><p>翻译: JulySong</p></blockquote><p>在以前的互联网范式 Web1 和 Web2 的背景下考虑 Web3 可能最有帮助。</p><h2 id="Web1（1980-年代-2000-年代初期）"><a href="#Web1（1980-年代-2000-年代初期）" class="headerlink" title="Web1（1980 年代 - 2000 年代初期）"></a>Web1（1980 年代 - 2000 年代初期）</h2><p>互联网的第一阶段 Web1 主要是为日常消费者提供在线内容和信息。</p><p>由于消费者只能在线阅读信息或内容，还不能与之互动，Web1 是令人难以置信的静态。</p><p>当您想到 Web1 时，请考虑 Internet Explorer、Yahoo 或 Netscape。虽然 web1 是只读的，但我们与 web1 关联的公司是建立在开放协议上的（这意味着几乎任何个人或组织都可以在互联网上构建并知道他们与下一个个人或组织遵守相同的规则）。</p><h2 id="什么是-Web2？"><a href="#什么是-Web2？" class="headerlink" title="什么是 Web2？"></a>什么是 Web2？</h2><p>Web2 是我们今天大多数人都知道和使用的互联网版本。Web1 是静态和“只读”的，而 Web2 是“读写”和交互式的。在 Web2 下，互联网变得更加可用：web2 是动态的，用户可以自己在互联网上消费、互动和创建内容。</p><p>一路走来，互联网在很大程度上被我们今天所知的苹果、亚马逊、Facebook 和谷歌这四个庞然大物所主导。Web2 还见证了智能手机使用的爆炸式增长，大部分互联网使用是通过这些公司构建的移动应用程序和硬件实现的。虽然这意味着更多的人可以参与互联网，但也意味着互联网越来越受到领先数字平台的控制。</p><p>为什么这是个问题？在我们今天所知的中心化互联网中，Apple 可以从所有付费应用下载和应用内购买中抽取 30% 的分成，Twitter 和 Facebook 可以取消美国总统的平台，日常消费者的隐私、安全性更少，并比以往任何时候都控制他们的在线信息。</p><p>我们还看到整个 web2 上发生了大量数据泄露事件，导致个人数据的安全性和隐私性降低。当用户的数据被泄露时，他们很容易成为身份盗窃、人身攻击等的受害者。</p><h2 id="什么是-Web3？"><a href="#什么是-Web3？" class="headerlink" title="什么是 Web3？"></a>什么是 Web3？</h2><p>Web3，我们正在走向的未来互联网，是一个去中心化的互联网。在 Web3 下，互联网是在线共享的，由集体“我们”管理，而不是由中心化实体拥有。Web3 世界是一个以开源协议为基础的世界。Web3 是关于重新架构互联网服务和产品，使它们造福于人而不是实体。</p><p>Web3 通过使其去中心化、分布式、开放、无需信任和无需许可来增强我们今天所知的网络。</p><ul><li>它的构建使得一切都以分散的分布式方式发生，没有中央机构访问控制系统。</li><li>“开放”是指由开放且可访问的开发人员社区构建并在全世界范围内执行的开源软件。</li><li>“不信任”是指网络本身允许参与者在没有受信任的第三方的情况下公开或私下进行交互。</li><li>“无许可”是指任何人，包括用户和供应商，都可以在未经管理机构授权的情况下参与。</li></ul><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>Web1：阅读 📖</p><p>Web2：读写 📖 🖊️</p><p>Web3：读写拥有 📖 🖊️ 🔑</p><h2 id="必读"><a href="#必读" class="headerlink" title="必读"></a>必读</h2><ul><li><a href="https://www.freecodecamp.org/news/what-is-web3/">什么是 Web3</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.xenonstack.com/blog/web3-features-and-challenges">Web3 功能及其比较 Web3 与 Web2</a></li><li><a href="https://ethereum.org/en/developers/docs/web2-vs-web3/">Web2 与 Web3</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 Web2 应用程序趋于中心化</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 在 Web2 应用程序中更容易发生数据泄露</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Web3 无需许可即可进入</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Web3 应用程序趋于中心化</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Web3 应用程序趋于分布式</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Web3 不需要对中央权威的信任</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Web3 对所有人开放和包容</p><p>A: 真的</p><p>B: 错误的</p></li><li><p>🤔 Web3 由一些受信任的实体控制</p><p>A: 真的</p><p>B: 错误的</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>A</li><li>A</li><li>B</li><li>A</li><li>A</li><li>A</li><li>B</li></ol></blockquote>]]></content>
    
    
    <summary type="html">在本模块中，您将了解什么是 web3。</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level1:什么是区块链?</title>
    <link href="http://blog.julysong.com/2022/08/02/web3-freshman-level1/"/>
    <id>http://blog.julysong.com/2022/08/02/web3-freshman-level1/</id>
    <published>2022-08-02T08:50:18.000Z</published>
    <updated>2025-02-20T06:39:02.266Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/what-is-blockchain">https://www.learnweb3.io/tracks/freshman/what-is-blockchain</a></p><p>翻译: JulySong</p></blockquote><p>区块链是计算机网络上多个节点之间共享的共享、分布式和永久数据库。他们以一种不可能修改或破解系统的方式记录数据。</p><p>具体来说，就像它的名字一样，区块链将数据记录为一个区块链。每个区块都包含一组交易，这些交易可以在网络上传输资产，或者更新存储在区块链上的信息。</p><p>区块链是由匿名人士（或团体）中本聪在 2008 年发布<a href="https://bitcoin.org/">比特币网络</a>时推广的。比特币是一种加密货币网络，它主要处理 BTC 资产在网络上的转移，没有受信任的中间人或权威机构，同时确保网络本身是安全的，不会被黑客入侵。（PS 比特币网络也可能是世界上最大的漏洞赏金——如果你能破解它，你就是一个瞬间的亿万富翁）。</p><p>随着时间的推移，比特币的这种设计激发了其他更强大的区块链网络的出现，比如<a href="https://ethereum.org/">以太坊</a>。在接下来的课程中，我们将学习很多关于以太坊的知识。</p><h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level1/2.png?raw=true"></p><p>区块链在启动时以创世纪状态开始。比特币的创世状态发生在 2009 年公共网络启动时。以太坊的创世纪状态发生在 2015 年推出时。</p><p>区块链上的每笔交易都会修改跨所有节点复制的全局状态。</p><p><img src="https://github.com/songhanlin/hexo-image/blob/master/web3-freshman-level1/3.png?raw=true"><br>由于有数百万笔交易，交易被组合成块。由此得名。这些块以可加密验证的方式链接在一起，因此它们在历史上是可追溯的。网络的当前状态可以随时重新计算，从创世块开始，根据每个块的信息转换状态，直到现在。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><a href="https://en.wikipedia.org/wiki/Peer-to-peer">区块链网络通过计算机节点的点对点</a>分布式网络自主管理。无需过多详细说明，您可以简单地将网络中的每个节点视为保存全局交易分类帐的副本。因此，每个节点都可以单独验证和审计网络上发生的交易，并确保没有非法行为。</p><p>另一种类型的节点，称为<a href="https://en.wikipedia.org/wiki/Bitcoin#Mining">挖掘节点</a>，负责将网络上进行的新交易组合成一个区块，对其进行验证，并提议将该区块包含在其他所有人的全球分类账中。挖矿在计算上是困难的，并且安全地进行非常重要，因此区块被接受的矿工会因其辛勤工作而获得代币奖励。</p><p>区块链的使用证实了每个价值单位只转移一次，中本聪提出的巧妙机制解决了长期存在的去中心化<a href="https://en.wikipedia.org/wiki/Double-spending">双花</a>问题。</p><h2 id="权利下放"><a href="#权利下放" class="headerlink" title="权利下放"></a>权利下放</h2><p>通过将数据存储在节点的对等网络中，区块链是一个去中心化的网络。与以集中方式存储数据的传统方法相比，这具有显着优势。有很多集中化问题的重要例子——我们将在这里列出其中的一些：</p><ul><li>集中式系统中的数据泄露会暴露大量数据</li><li>中央当局可以审查和关闭言论</li><li>对中央权威的依赖意味着上游问题会影响下游消费者（例如，AWS 宕机意味着大部分互联网也随之宕机）</li></ul><p>另一方面，去中心化带来了相反的好处。</p><ul><li>没有审查制度，因为没有单一的权威或中间人可以审查你</li><li>由于整个网络在全球 1000 个节点上运行，因此无需停机</li><li>高度抗攻击性使其无法操纵或破坏数据</li></ul><h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><ul><li>加密货币</li><li>智能合约</li><li>去中心化金融</li><li>赌博</li><li>供应链追踪</li><li>防伪保护</li><li>数据隐私</li><li>去中心化治理</li><li>可验证的资产所有权</li></ul><p>还有很多…</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>要了解有关区块链的更多信息，我们强烈建议您使用以下资源：</p><h3 id="必须注意"><a href="#必须注意" class="headerlink" title="必须注意"></a>必须注意</h3><ul><li><a href="https://www.youtube.com/watch?v=bBC-nXj3Ng4">但是比特币实际上是如何运作的呢？由 3Blue1Brown</a></li><li><a href="https://andersbrownworth.com/blockchain/">Anders Brownworth 的区块链演示</a></li></ul><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><ul><li><a href="https://bitsonblocks.net/2015/09/09/gentle-introduction-blockchain-technology/">Bits On Blocks 对区块链技术的温和介绍</a></li><li><a href="https://www.youtube.com/watch?v=SSo_EIwHSd4">简单解释的区块链是如何工作的</a></li></ul><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 谁创造了比特币?</p><p>A: 中本聪</p><p>B: 克雷格·赖特</p><p>C: 约翰迈克菲</p></li><li><p>🤔 什么是区块链？</p><p>A: 一种加密货币</p><p>B: 在对等节点网络上运行的分布式数据库</p><p>C: 中本聪运行的数据库</p></li><li><p>🤔 什么是创世区块？</p><p>A: 区块链上的创世纪之书</p><p>B: 区块链的初始状态</p><p>C: 区块链上的第一笔交易</p></li><li><p>🤔 您的加密货币资产存储在哪里？</p><p>A: 在您的数字钱包中</p><p>B: 在 1000 个区块链节点中</p><p>C: 在您的银行账户中</p></li><li><p>🤔 什么是矿工？</p><p>A: 负责验证和审计交易的节点</p><p>B: 有人在地下开采黄金</p><p>C: 负责提出新区块、验证和审计交易的节点</p></li><li><p>🤔 为什么矿工要努力保护网络？</p><p>A: 对于块奖励</p><p>B: 出于善意</p><p>C: 出于政治原因</p></li><li><p>🤔 什么是区块链网络中的节点？</p><p>A: 一种编程语言</p><p>B: 一种加密货币代币</p><p>C: 运行区块链软件的计算机</p></li><li><p>🤔 P2P 是什么意思？</p><p>A: 点对点</p><p>B: 产品到产品</p><p>C: 私钥密码</p></li><li><p>🤔 什么是区块链技术的有效用例？</p><p>A: 存储和转移资产</p><p>B: 参与去中心化治理</p><p>C: 跟踪整个供应链的食品</p><p>D: 上述所有的</p></li><li><p>🤔 区块链分裂时的术语是什么？</p><p>A: 叉子</p><p>B: 勺子</p><p>C: 合并</p><p>D: 切</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>B</li><li>B</li><li>B</li><li>C</li><li>A</li><li>C</li><li>A</li><li>D</li><li>A</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之新手篇</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  <entry>
    <title>WEB3系列教程之新手篇--level0:基础编程</title>
    <link href="http://blog.julysong.com/2022/08/02/web3-freshman-level0/"/>
    <id>http://blog.julysong.com/2022/08/02/web3-freshman-level0/</id>
    <published>2022-08-02T08:26:36.000Z</published>
    <updated>2025-02-20T06:39:02.266Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址: <a href="https://www.learnweb3.io/tracks/freshman/basic-programming">https://www.learnweb3.io/tracks/freshman/basic-programming</a></p><p>翻译: JulySong</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>要开始在 Web3 中构建应用程序，我们需要一些 Web2 的背景知识。web2 中肯定涵盖了许多在 Web3 中非常有用的主题。</p><p>例如，如果您制作了一份智能合约，您仍然需要为您的用户提供一种与该智能合约进行交互的方式。您可以通过构建允许用户以简单方式与智能合约交互的网站或应用程序来做到这一点。</p><p>此外，您可能还想在智能合约之外存储一些用户数据或其他数据。这些概念与 Web2 完全相同，唯一不同的是我们将在后台使用智能合约并与之交互。</p><h2 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h2><p>前端是用户与之交互的界面。在网络上，前端是指您可以浏览的网站。移动应用程序和桌面应用程序也是有效前端接口的示例。就本课程而言，我们将专注于 Web，并使用 HTML、CSS 和 Javascript 等 Web 技术开发前端界面。</p><ul><li><a href="https://betterprogramming.pub/frontend-development-the-essentials-1c1290b43590">前端开发要点</a></li><li><a href="https://scrimba.com/learn/learnjavascript">免费学习 JavaScript</a></li><li><a href="https://scrimba.com/learn/learnreact">免费学习 React</a></li></ul><h2 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h2><p>后端是指软件中允许其运行并且用户不能（必然）直接访问的部分。大多数私有数据、用户数据、业务逻辑、数据处理等都发生在后端，而前端仅用于提供该数据的可视化表示并允许用户使用它执行某些任务。后端接收来自客户端的请求，并包含将适当数据发送回客户端的逻辑。后端服务可以用多种编程语言编写——Python、Java、Javascript、Go、Rust 等。</p><p>在 Web 上，前端网站通常通过 Internet 通过 HTTP 向后端服务器发送请求，请求某些数据或要求它执行某个任务，然后后端注册请求并发送回响应。出于本课程的目的，我们还将使用 Javascript 开发我们的后端，以便能够重用代码并在前端和后端之间共享知识。</p><p>必读:</p><ul><li><a href="https://www.codecademy.com/article/back-end-architecture">什么是后端?</a></li><li><a href="https://www.freecodecamp.org/learn/back-end-development-and-apis/#basic-node-and-express">使用 Node.js 和 Express 构架 API</a></li><li><a href="https://www.freecodecamp.org/learn/back-end-development-and-apis/#back-end-development-and-apis-projects">在 Node.js 中构建链接到数据库的 API</a></li></ul><hr><p>在继续讨论实际的 web3 特定内容之前，请确保您熟悉以下内容：</p><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>Node.js</li><li>React.js</li></ul><p>如果您愿意，您可以并行学习它们，但拥有背景知识肯定会有所帮助！尤其是当您继续在大一以外的轨道上行驶时。</p><hr><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li><p>🤔 什么是前端?</p><p>A: 用户与之交互的界面</p><p>B: 接收来自客户端的请求, 并包含发送适当数据的逻辑</p></li><li><p>🤔 什么是后端?</p><p>A: 用户与之交互的界面</p><p>B: 接收来自客户端的请求, 并包含发送适当数据的逻辑</p></li><li><p>🤔 什么是 API?</p><p>A: 以持久方式将数据保存到内存的接口</p><p>B: 用于在不同软件组件之间进行通信的接口</p></li><li><p>🤔 什么是数据库?</p><p>A: 以持久方式将数据保存到内存的接口</p><p>B: 用于在不同软件组件之间进行通信的接口</p></li></ol><blockquote><p>参考答案:</p><ol><li>A</li><li>B</li><li>B</li><li>A</li></ol></blockquote>]]></content>
    
    
    <summary type="html">WEB3系列教程之新手篇</summary>
    
    
    
    <category term="web3系列之新手篇" scheme="http://blog.julysong.com/categories/web3%E7%B3%BB%E5%88%97%E4%B9%8B%E6%96%B0%E6%89%8B%E7%AF%87/"/>
    
    
    <category term="web3" scheme="http://blog.julysong.com/tags/web3/"/>
    
  </entry>
  
  
    <follow_challenge>
      <feedId>115293114462569472</feedId>
      <userId>76516807322716160</userId>
    </follow_challenge>
  
</feed>
